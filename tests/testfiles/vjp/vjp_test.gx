package vjp

import (
	"math"
	"math/grad"
)

func F(x float32) float32 {
	return math.Sin[float32](x)
}

func TestVJPF() func(x float32) (float32, func(res float32) float32) {
	return grad.VJP(F)
	// Want:
	// func(x float32) (float32, func(res float32) float32) {
	// 	fwd0, SinVJP := grad.VJP(math.Sin)[float32](x)
	// 	selfVJPFunc := func(res float32) float32 {
	// 		bck0 := SinVJP(res)
	// 		return bck0
	// 	}
	// 	return fwd0, selfVJPFunc
	// }
}

func SoftMax(x float32) float32 {
	return 1 / (1 + math.Exp(-x))
}

func TestVJPSoftMax() (float32, float32) {
	vjp := grad.VJP(SoftMax)
	trace(vjp)
	y, bck := vjp(0.8)
	return y, bck(1)
	// Want:
	// 0: float32(0.689974)
	// 1: float32(0.21391)
	// Trace:
	// vjp_test.gx:0
	// 	func(x float32) (float32, func(res float32) float32) {
	// 		fwd0 := -x
	// 		fwd1, ExpVJP := grad.VJP(math.Exp)[float32](fwd0)
	// 		fwd2 := 1+fwd1
	// 		fwd3 := 1/fwd2
	// 		selfVJPFunc := func(res float32) float32 {
	// 			bck3x := res/fwd2
	// 			bck3y := -res/(fwd2*fwd2)
	// 			bck1 := ExpVJP(bck3y)
	// 			bck0 := -bck1
	// 			return bck0
	// 		}
	// 		return fwd3, selfVJPFunc
	// 	}
}

