// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package testing

import (
	"fmt"
	"go/ast"
	"strings"

	"github.com/pkg/errors"
	"github.com/gx-org/gx/build/fmterr"
	"github.com/gx-org/gx/build/ir"
)

const errorPrefix = "ERROR"

type (
	errorInspector struct {
		pkg                *ir.Package
		fileToLineToErrors map[string]map[int]fmterr.ErrorWithPos
		numExpected        int
	}
)

func newErrorInspector(pkg *ir.Package) (*errorInspector, int) {
	ei := &errorInspector{
		pkg:                pkg,
		fileToLineToErrors: make(map[string]map[int]fmterr.ErrorWithPos),
	}
	for name, file := range pkg.Files {
		errs := make(map[int]fmterr.ErrorWithPos)
		ei.collectPackageLevelErrors(errs, file)
		ei.collectFuncBodyErrors(errs, file)
		ei.fileToLineToErrors[name] = errs
		ei.numExpected += len(errs)
	}
	return ei, ei.numExpected
}

func (ei *errorInspector) collectPackageLevelErrors(errs map[int]fmterr.ErrorWithPos, file *ir.File) {
	for _, decl := range file.Src.Decls {
		switch declT := decl.(type) {
		case *ast.GenDecl:
			ei.collectGenDeclErrors(errs, declT)
		case *ast.FuncDecl:
			ei.commentGroupToError(errs, declT.Doc)
		}
	}
}

func (ei *errorInspector) collectGenDeclErrors(errs map[int]fmterr.ErrorWithPos, decl *ast.GenDecl) {
	for _, spec := range decl.Specs {
		var comment *ast.CommentGroup
		switch specT := spec.(type) {
		case *ast.ValueSpec:
			comment = specT.Comment
		case *ast.TypeSpec:
			comment = specT.Comment
		case *ast.ImportSpec:
			comment = specT.Comment
		}
		ei.commentGroupToError(errs, comment)
	}
}

func (ei *errorInspector) collectFuncBodyErrors(errs map[int]fmterr.ErrorWithPos, file *ir.File) {
	for _, cmt := range file.Src.Comments {
		ei.commentGroupToError(errs, cmt)
	}
}

func (ei *errorInspector) commentGroupToError(errs map[int]fmterr.ErrorWithPos, group *ast.CommentGroup) {
	if group == nil {
		return
	}
	for _, cmt := range group.List {
		ei.commentToError(errs, cmt)
	}
}

func (ei *errorInspector) commentToError(errs map[int]fmterr.ErrorWithPos, cmt *ast.Comment) {
	for text := range strings.SplitSeq(cmt.Text, "//") {
		text = strings.TrimSpace(text)
		if !strings.HasPrefix(text, errorPrefix) {
			continue
		}
		text = strings.TrimPrefix(text, errorPrefix)
		text = strings.TrimSpace(text)
		cmtPos := ei.pkg.FSet.Position(cmt.Pos())
		errs[cmtPos.Line] = fmterr.Error(
			ei.pkg.FSet,
			cmt,
			errors.New(text),
		)
	}
}

func (ei *errorInspector) notFoundExpectedErrors() error {
	errs := fmterr.Errors{}
	for _, lineToError := range ei.fileToLineToErrors {
		for _, err := range lineToError {
			notFoundErr := err
			pos := err.Pos().Position()
			notFoundErr = fmterr.Errorf(
				ei.pkg.FSet,
				notFoundErr.Pos().Node,
				"%s:%d: expected error not found: %s",
				pos.Filename, pos.Line, err.Err().Error(),
			)
			errs.Append(notFoundErr)
		}
	}
	return errs.ToError()
}

// processPackageErrors goes through all the errors of the package and
// compare them to the errors generated by the compiler.
//
// If the same error is found, it is removed from the set of errors of the package
// and from the set of expected errors.
func (ei *errorInspector) processPackageErrors(err error) error {
	var errPos fmterr.ErrorWithPos
	if !errors.As(err, &errPos) {
		return err
	}
	pos := errPos.Pos().Position()
	fileErrors := ei.fileToLineToErrors[pos.Filename]
	if fileErrors == nil {
		return err
	}
	lineError, ok := fileErrors[pos.Line]
	if !ok {
		return err
	}
	// An expected error has been found on the same line.
	// We can remove it from the set of expected errors.
	delete(fileErrors, pos.Line)
	compilerText := err.Error()
	expectedText := lineError.Err().Error()
	// Check if the text of the generated error contains the string specified in the comments.
	if strings.Contains(compilerText, expectedText) {
		return nil
	}
	// The error is expected but does not have the correct message.
	// We transform the error to transform the report such finding.
	return fmterr.Errorf(ei.pkg.FSet, lineError.Pos().Node, "incorrect compiler error:\n%s\nbut want an error message that contains %q", compilerText, expectedText)
}

// CompareToExpectedErrors removes errors declared in the source code using:
// ERROR <sub string to search in the error message>
// from a set of errors and returns the remaining errors if any.
//
// First, all expected errors are collected from the comments. Second, these errors
// are compared to the errors generated by the compiler. If some errors have been
// generated by the compiler and are not expected, an error is returned. If some
// errors are expected in the comments and have not been generated by the compiler,
// an error is returned.
func CompareToExpectedErrors(pkg *ir.Package, err error) (int, error) {
	inspector, numExpectedErrors := newErrorInspector(pkg)
	if err == nil {
		// If the builder generated no errors, then we return the errors that are expected.
		return 0, inspector.notFoundExpectedErrors()
	}
	pkgErrs, ok := err.(*fmterr.Errors)
	if !ok {
		// If the error that has been generated is not a list of errors,
		// then an error occurred before we could build the package.
		// So, we return it.
		return 1, err
	}
	if numExpectedErrors == 0 {
		// Errors have been generated but we do not expect any.
		// So, we return the unexpected errors.
		return numExpectedErrors, pkgErrs.ToError()
	}
	out := fmterr.Errors{}
	pkgErrs = pkgErrs.Transform(inspector.processPackageErrors)
	if pkgErrs != nil {
		// Even after we have removed the expected errors, there are still
		// some errors left. So, we add them to out.
		out.Append(fmt.Errorf("unexpected error(s) in the package:\n%+w", pkgErrs))
	}
	remainingErrs := inspector.notFoundExpectedErrors()
	if remainingErrs != nil {
		// Some errors were expected but could not be found.
		// So, we add these expected errors to out.
		out.Append(fmt.Errorf("expected error(s) in the package that could not be found:\n%w", remainingErrs))
	}
	testFuncs := findTests(pkg)
	if len(testFuncs) == 0 {
		return numExpectedErrors, out.ToError()
	}
	// A package with expected errors cannot have test functions.
	// These tests would not be run anyway.
	for _, fn := range testFuncs {
		out.Append(fmterr.Errorf(pkg.FSet, fn.Node(), "test function %s in a package with expected errors not supported", fn.Name()))
	}
	return numExpectedErrors, out.ToError()
}
