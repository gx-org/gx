package builder_test

import (
	"fmt"
	"go/parser"
	"go/token"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
	gxfmt "github.com/gx-org/gx/base/fmt"
	"github.com/gx-org/gx/build/builder"
	"github.com/gx-org/gx/build/fmterr"
	"github.com/gx-org/gx/build/ir"
	"github.com/gx-org/gx/build/ir/irhelper"
	"github.com/gx-org/gx/build/ir/irstring"
)

func buildSource(ctx *testContext, src string) (builder.Package, error) {
	fileDecl, err := parser.ParseFile(token.NewFileSet(), "", src, parser.ParseComments|parser.SkipObjectResolution)
	if err != nil {
		return nil, err
	}
	bld := builder.New(&ctx.imp)
	pkg := bld.NewIncrementalPackage(fileDecl.Name.Name)
	return pkg, pkg.Build(src)
}

var (
	wantPackage = &ir.Package{Name: irhelper.Ident("test")}
	wantFile    = &ir.File{Package: wantPackage}
)

func compare(done map[any]bool, got, want ir.Node) error {
	gotS := irstring.ReflectString(done, got)
	wantS := irstring.ReflectString(done, want)
	if gotS != wantS {
		if irstring.ReflectStringOutput == irstring.SilentStringType {
			return fmt.Errorf("got IR not matching expectation")
		}
		return fmt.Errorf("diff:\n%s\ngot:\n%s\nwant:\n%s", cmp.Diff(gotS, wantS), gxfmt.Number(gotS), gxfmt.Number(wantS))
	}
	return nil
}

func check[T ir.Node](nextWant *int, pkg *ir.Package, wants []ir.Node, gots []T) error {
	done := map[any]bool{pkg: true}
	for _, gotT := range gots {
		if *nextWant >= len(wants) {
			return fmt.Errorf("too many structures generated by the builder")
		}
		if err := compare(done, gotT, wants[*nextWant]); err != nil {
			return fmt.Errorf("incorrect IR at position %d:\n%s", *nextWant, err)
		}
		*nextWant++
	}
	return nil
}

func checkAll(wants []ir.Node, decls *ir.Declarations) error {
	if len(wants) == 0 {
		return nil
	}
	if decls == nil {
		return fmt.Errorf("no declarations created by the builder")
	}
	nextWant := 0
	if err := check(&nextWant, decls.Package, wants, decls.Types); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Vars); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Consts); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Funcs); err != nil {
		return err
	}
	if nextWant != len(wants) {
		return fmt.Errorf("builder only generated %d structures but want to check %d structures", nextWant, len(wants))
	}
	return nil
}

type declarePackage struct {
	src  string
	post func(*ir.Package)
}

func (tt declarePackage) source() string {
	return tt.src
}

func (tt declarePackage) run(ctx *testContext) error {
	pkg, err := buildSource(ctx, tt.src)
	if err != nil {
		return err
	}
	if tt.post != nil {
		tt.post(pkg.IR())
	}
	ctx.imp.pkgs[pkg.IR().Name.Name] = pkg
	return nil
}

type irDeclTest struct {
	src  string
	want []ir.Node
	err  string
}

func (tt irDeclTest) source() string {
	return tt.src
}

func (tt irDeclTest) run(ctx *testContext) error {
	pkg, err := buildSource(ctx, fmt.Sprintf(`
package test

%s
`, tt.src))
	if err := checkError(tt.err, err); err != nil {
		return err
	}
	if err := checkAll(tt.want, pkg.IR().Decls); err != nil {
		return err
	}
	return nil
}

type irExprTest struct {
	src      string
	want     ir.Expr
	wantType string
	err      string
}

func checkNilError(err error) error {
	if err == nil {
		return nil
	}
	errs, ok := err.(*fmterr.Errors)
	if !ok {
		return err
	}
	if errs.Empty() {
		return errors.Errorf("compiler returned an empty list of errors")
	}
	return err
}

func checkError(want string, err error) error {
	if want == "" {
		return checkNilError(err)
	}
	if err == nil {
		return errors.Errorf("got no error but want an error which contains %q", want)
	}
	if !strings.Contains(err.Error(), want) {
		return errors.Errorf("got error %q but want an error which contains %q", err.Error(), want)
	}
	return nil
}

func (tt irExprTest) run(ctx *testContext) error {
	done := map[any]bool{}
	bld := builder.New(&ctx.imp)
	pkg := bld.NewIncrementalPackage("test")
	got, err := pkg.BuildExpr(tt.src)
	if err := checkError(tt.err, err); err != nil {
		return err
	}
	if err := compare(done, got, tt.want); err != nil {
		return err
	}
	if tt.wantType == "" {
		return nil
	}
	gotType := got.Type().String()
	if gotType != tt.wantType {
		return errors.Errorf("incorrect type string: got %q want %q", gotType, tt.wantType)
	}
	return nil
}

func (tt irExprTest) source() string {
	return tt.src
}

type localImporter struct {
	pkgs map[string]builder.Package
}

func (imp *localImporter) Load(bld *builder.Builder, path string) (builder.Package, error) {
	pkg, ok := imp.pkgs[path]
	if !ok {
		return nil, errors.Errorf("package %s has not been built", path)
	}
	return pkg, nil
}

type (
	testContext struct {
		imp localImporter
	}

	irTest interface {
		source() string
		run(*testContext) error
	}
)

func testAll(t *testing.T, tests ...irTest) {
	t.Helper()
	ctx := &testContext{
		imp: localImporter{pkgs: make(map[string]builder.Package)},
	}
	for i, test := range tests {
		if _, ok := test.(declarePackage); ok {
			if err := test.run(ctx); err != nil {
				t.Fatal(err)
			}
		}
		t.Run(fmt.Sprintf("test%d", i), func(t *testing.T) {
			t.Helper()
			if err := test.run(ctx); err != nil {
				t.Errorf("\n%s\n%+v", test.source(), fmterr.ToStackTraceError(err))
			}
		})
	}
}
