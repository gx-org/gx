// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package testbuild provides helper functions to test the build step in GX.
package testbuild

import (
	"fmt"
	"go/parser"
	"go/token"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
	gxfmt "github.com/gx-org/gx/base/fmt"
	"github.com/gx-org/gx/build/builder"
	"github.com/gx-org/gx/build/fmterr"
	"github.com/gx-org/gx/build/ir"
	"github.com/gx-org/gx/build/ir/irstring"
)

func buildSource(ctx *testContext, src string) (builder.Package, error) {
	fileDecl, err := parser.ParseFile(token.NewFileSet(), "", src, parser.ParseComments|parser.SkipObjectResolution)
	if err != nil {
		return nil, err
	}
	bld := builder.New(&ctx.imp)
	pkg := bld.NewIncrementalPackage(fileDecl.Name.Name)
	return pkg, pkg.Build(src)
}

func compare(done map[any]bool, got, want ir.Node) error {
	gotS := irstring.ReflectString(done, got)
	wantS := irstring.ReflectString(done, want)
	if gotS != wantS {
		if irstring.ReflectStringOutput == irstring.SilentStringType {
			return fmt.Errorf("got IR not matching expectation")
		}
		return fmt.Errorf("diff:\n%s\ngot:\n%s\nwant:\n%s", cmp.Diff(gotS, wantS), gxfmt.Number(gotS), gxfmt.Number(wantS))
	}
	return nil
}

func check[T ir.Node](nextWant *int, pkg *ir.Package, wants []ir.Node, gots []T) error {
	done := map[any]bool{pkg: true}
	for _, gotT := range gots {
		if *nextWant >= len(wants) {
			return fmt.Errorf("too many structures generated by the builder")
		}
		if err := compare(done, gotT, wants[*nextWant]); err != nil {
			return fmt.Errorf("incorrect IR at position %d:\n%s", *nextWant, err)
		}
		*nextWant++
	}
	return nil
}

func checkAll(wants []ir.Node, decls *ir.Declarations) error {
	if len(wants) == 0 {
		return nil
	}
	if decls == nil {
		return fmt.Errorf("no declarations created by the builder")
	}
	nextWant := 0
	if err := check(&nextWant, decls.Package, wants, decls.Types); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Vars); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Consts); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Funcs); err != nil {
		return err
	}
	if nextWant != len(wants) {
		return fmt.Errorf("builder only generated %d structures but want to check %d structures", nextWant, len(wants))
	}
	return nil
}

// DeclarePackage declares a package for the following tests.
type DeclarePackage struct {
	// Source code of the package.
	Src string
	// Function called (if not nil)  after the package has been built.
	// Can be use to provide the implementation of builtin functions.
	Post func(*ir.Package)
}

func (tt DeclarePackage) source() string {
	return tt.Src
}

func (tt DeclarePackage) run(ctx *testContext) error {
	pkg, err := buildSource(ctx, tt.Src)
	if err != nil {
		return err
	}
	if tt.Post != nil {
		tt.Post(pkg.IR())
	}
	ctx.imp.pkgs[pkg.IR().Name.Name] = pkg
	return nil
}

// DeclTest specifies a test with GX code declarations.
type DeclTest struct {
	// Src is the GX source code.
	Src string
	// Want is the set of nodes that is expected from the compiler to build.
	// If nil (or length 0), the output of the compiler is not checked.
	Want []ir.Node
	// Err is the substring expected if the compiler returns an error.
	Err string
}

func (tt DeclTest) source() string {
	return tt.Src
}

func (tt DeclTest) run(ctx *testContext) error {
	pkg, err := buildSource(ctx, fmt.Sprintf(`
package test

%s
`, tt.Src))
	if err := checkError(tt.Err, err); err != nil {
		return err
	}
	if err := checkAll(tt.Want, pkg.IR().Decls); err != nil {
		return err
	}
	return nil
}

// ExprTest specifies a test of a GX expression.
type ExprTest struct {
	// Src is the source code of the expression.
	Src string
	// Want is the expression expected to be built by the compiler.
	Want ir.Expr
	// WantType is the string representation of the expression expected to be built by the compiler.
	WantType string
	// Err is the error expected by the compiler when the expression does not compile.
	Err string
}

func checkNilError(err error) error {
	if err == nil {
		return nil
	}
	errs, ok := err.(*fmterr.Errors)
	if !ok {
		return err
	}
	if errs.Empty() {
		return errors.Errorf("compiler returned an empty list of errors")
	}
	return err
}

func checkError(want string, err error) error {
	if want == "" {
		return checkNilError(err)
	}
	if err == nil {
		return errors.Errorf("got no error but want an error which contains %q", want)
	}
	if !strings.Contains(err.Error(), want) {
		return errors.Errorf("got error %q but want an error which contains %q", err.Error(), want)
	}
	return nil
}

func (tt ExprTest) run(ctx *testContext) error {
	done := map[any]bool{}
	bld := builder.New(&ctx.imp)
	pkg := bld.NewIncrementalPackage("test")
	got, err := pkg.BuildExpr(tt.Src)
	if err := checkError(tt.Err, err); err != nil {
		return err
	}
	if err := compare(done, got, tt.Want); err != nil {
		return err
	}
	if tt.WantType == "" {
		return nil
	}
	gotType := got.Type().String()
	if gotType != tt.WantType {
		return errors.Errorf("incorrect type string: got %q want %q", gotType, tt.WantType)
	}
	return nil
}

func (tt ExprTest) source() string {
	return tt.Src
}

type localImporter struct {
	pkgs map[string]builder.Package
}

func (imp *localImporter) Load(bld *builder.Builder, path string) (builder.Package, error) {
	pkg, ok := imp.pkgs[path]
	if !ok {
		return nil, errors.Errorf("package %s has not been built", path)
	}
	return pkg, nil
}

type (
	testContext struct {
		imp localImporter
	}

	irTest interface {
		source() string
		run(*testContext) error
	}
)

// Run all the test.
func Run(t *testing.T, tests ...irTest) {
	t.Helper()
	ctx := &testContext{
		imp: localImporter{pkgs: make(map[string]builder.Package)},
	}
	for i, test := range tests {
		if _, ok := test.(DeclarePackage); ok {
			if err := test.run(ctx); err != nil {
				t.Fatal(err)
			}
		}
		t.Run(fmt.Sprintf("test%d", i), func(t *testing.T) {
			t.Helper()
			if err := test.run(ctx); err != nil {
				t.Errorf("\n%s\n%+v", test.source(), fmterr.ToStackTraceError(err))
			}
		})
	}
}
