// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package testbuild provides helper functions to test the build step in GX.
package testbuild

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strconv"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
	"golang.org/x/exp/maps"
	gxfmt "github.com/gx-org/gx/base/fmt"
	"github.com/gx-org/gx/build/builder"
	"github.com/gx-org/gx/build/fmterr"
	"github.com/gx-org/gx/build/importers"
	"github.com/gx-org/gx/build/ir"
	"github.com/gx-org/gx/build/ir/irstring"
	gxtesting "github.com/gx-org/gx/tests/testing"
)

// CompareString compares two string and build an error message if the strings do not match.
func CompareString(got, want string) error {
	got = strings.TrimSpace(got)
	want = strings.TrimSpace(want)
	if got == want {
		return nil
	}
	return fmt.Errorf("diff:\n%s\ngot:\n%s\nwant:\n%s", cmp.Diff(got, want), gxfmt.Number(got), gxfmt.Number(want))
}

func compare(done map[any]bool, got, want ir.IR) error {
	gotS := irstring.ReflectString(done, got)
	wantS := irstring.ReflectString(done, want)
	return CompareString(gotS, wantS)
}

func check[T ir.IR](nextWant *int, pkg *ir.Package, wants []ir.IR, gots []T) error {
	done := map[any]bool{pkg: true}
	for _, gotT := range gots {
		if *nextWant >= len(wants) {
			return fmt.Errorf("too many structures generated by the builder")
		}
		if err := compare(done, gotT, wants[*nextWant]); err != nil {
			return fmt.Errorf("incorrect IR at position %d:\n%s", *nextWant, err)
		}
		*nextWant++
	}
	return nil
}

func checkAll(wants []ir.IR, decls *ir.Declarations) error {
	if len(wants) == 0 {
		return nil
	}
	if decls == nil {
		return fmt.Errorf("no declarations created by the builder")
	}
	nextWant := 0
	if err := check(&nextWant, decls.Package, wants, decls.Types); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Vars); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Consts); err != nil {
		return err
	}
	if err := check(&nextWant, decls.Package, wants, decls.Funcs); err != nil {
		return err
	}
	if nextWant != len(wants) {
		return fmt.Errorf("builder only generated %d structures but want to check %d structures", nextWant, len(wants))
	}
	return nil
}

type compileError struct {
	src string
	err error
}

func (ce *compileError) Error() string {
	return fmt.Sprintf("%s\nTest source:\n%s", ce.err.Error(), gxfmt.Number(ce.src))
}

func (ce *compileError) Unwrap() error {
	return ce.err
}

// DeclarePackage declares a package for the following tests.
type DeclarePackage struct {
	// Path where the package belongs (without the name).
	Path string
	// Source code of the package.
	Src string
	// Function called (if not nil)  after the package has been built.
	// Can be use to provide the implementation of builtin functions.
	Post func(*ir.Package)
}

// Source code of the package.
func (tt DeclarePackage) Source() string {
	return tt.Src
}

// Build the package.
func (tt DeclarePackage) Build(b *builder.Builder) (importers.Package, error) {
	pkg, err := build(b, tt.Path, tt.Src)
	if err != nil {
		return nil, err
	}
	if tt.Post != nil {
		tt.Post(pkg.IR())
	}
	return pkg, nil
}

// Run the source code to declare it as an importable package.
func (tt DeclarePackage) Run(b *Builder) error {
	pkg, err := tt.Build(builder.NewWithLoader(&b.imp))
	if err != nil {
		return err
	}
	b.imp.pkgs[pkg.IR().FullName()] = pkg
	return nil
}

// Decl specifies a test with GX code declarations.
type Decl struct {
	// Src is the GX source code.
	Src string
	// Want is the set of nodes that is expected from the compiler to build.
	// If nil (or length 0), the output of the compiler is not checked.
	Want []ir.IR
	// Err is the substring expected if the compiler returns an error.
	Err string

	// WantExprs compares expanded expressions to required GX source code.
	WantExprs map[string]string
}

// Source code of the declarations.
func (tt Decl) Source() string {
	return tt.Src
}

// CheckExpandedExpr builds an expression and compares the outcome to a string.
func CheckExpandedExpr(pkg *builder.IncrementalPackage, src string, want string, imports ...*ast.ImportSpec) error {
	irExpr, err := pkg.BuildExpr(src, imports...)
	if err != nil {
		return errors.Errorf("cannot build expression %q:\n%+v", src, err)
	}
	var got string
	switch irExprT := irExpr.(type) {
	case *ir.MacroCallExpr:
		got = irExprT.F.String()
	default:
		got = irExpr.String()
	}
	return CompareString(got, want)
}

// Run builds the declarations as a package, then compare to an expected outcome.
func (tt Decl) Run(b *Builder) error {
	pkg, err := b.Build("", fmt.Sprintf(`
package test

%s
`, tt.Src))
	if err := CheckError(tt.Err, err); err != nil {
		return err
	}
	if err := checkAll(tt.Want, pkg.IR().Decls); err != nil {
		return err
	}
	// Check other functions we expect.
	for expr, want := range tt.WantExprs {
		if err := CheckExpandedExpr(pkg, expr, want, b.imp.importSpecs()...); err != nil {
			return err
		}
	}
	return nil
}

// Expr specifies a test of a GX expression.
type Expr struct {
	// Src is the source code of the expression.
	Src string
	// Want is the expression expected to be built by the compiler.
	Want ir.Expr
	// WantType is the string representation of the expression expected to be built by the compiler.
	WantType string
	// Err is the error expected by the compiler when the expression does not compile.
	Err string
}

func checkNilError(err error) error {
	if err == nil {
		return nil
	}
	builderError := err
	if cErr, ok := err.(*compileError); ok {
		builderError = cErr.err
	}
	errs, ok := builderError.(*fmterr.Errors)
	if !ok {
		return err
	}
	if errs.Empty() {
		return errors.Errorf("compiler returned an empty list of errors")
	}
	return err
}

// CheckError checks if an error is expected.
func CheckError(want string, err error) error {
	if want == "" {
		return checkNilError(err)
	}
	if err == nil {
		return errors.Errorf("got no error but want an error which contains %q", want)
	}
	if !strings.Contains(err.Error(), want) {
		return errors.Errorf("got error %q but want an error which contains %q", err.Error(), want)
	}
	return nil
}

// Run the expression test.
func (tt Expr) Run(ctx *Builder) error {
	done := map[any]bool{}
	bld := builder.NewWithLoader(&ctx.imp)
	pkg := bld.NewIncrementalPackage("test")
	got, err := pkg.BuildExpr(tt.Src)
	if err := CheckError(tt.Err, err); err != nil {
		return err
	}
	if err := compare(done, got, tt.Want); err != nil {
		return err
	}
	if tt.WantType == "" {
		return nil
	}
	gotType := got.Type().String()
	if gotType != tt.WantType {
		return errors.Errorf("incorrect type string: got %q want %q", gotType, tt.WantType)
	}
	return nil
}

// Source code of the expression.
func (tt Expr) Source() string {
	return tt.Src
}

type localImporter struct {
	pkgs map[string]importers.Package
}

func (imp *localImporter) Load(bld importers.Builder, path string) (importers.Package, error) {
	pkg, ok := imp.pkgs[path]
	if !ok {
		return nil, errors.Errorf("package %s has not been built", path)
	}
	return pkg, nil
}

func (imp *localImporter) importSpecs() []*ast.ImportSpec {
	specs := make([]*ast.ImportSpec, len(imp.pkgs))
	for i, path := range maps.Keys(imp.pkgs) {
		specs[i] = &ast.ImportSpec{
			Path: &ast.BasicLit{Value: strconv.Quote(path)},
		}
	}
	return specs
}

// Builder builds test source code.
type Builder struct {
	imp  localImporter
	next int
}

func (b *Builder) nextTestName() string {
	name := fmt.Sprintf("test%d", b.next)
	b.next++
	return name
}

func build(bld *builder.Builder, path, src string) (*builder.IncrementalPackage, error) {
	// Construct the full path of the package.
	fileDecl, err := parser.ParseFile(token.NewFileSet(), "", src, parser.PackageClauseOnly)
	fullPath := "<unknown>"
	if fileDecl != nil && fileDecl.Name != nil {
		fullPath = fileDecl.Name.Name
	}
	if path != "" {
		fullPath = path + "/" + fullPath
	}
	// Build the package given its full path.
	pkg := bld.NewIncrementalPackage(fullPath)
	if err != nil {
		return pkg, &compileError{src: src, err: err}
	}
	err = pkg.Build(src)
	// Compare errors to what we expect from the package source code.
	_, err = gxtesting.CompareToExpectedErrors(pkg.IR(), err)
	if err != nil {
		// Some errors are unexpected: return.
		return pkg, &compileError{src: src, err: err}
	}
	// Everything is fine: returns the package.
	return pkg, nil
}

// Build test source code.
func (b *Builder) Build(path, src string) (*builder.IncrementalPackage, error) {
	return build(builder.NewWithLoader(&b.imp), path, src)
}

// Loader returns the package loader of the builder.
func (b *Builder) Loader() importers.Loader {
	return &b.imp
}

// Test to run.
type Test interface {
	Source() string
	Run(*Builder) error
}

// Run all the test.
func Run(t *testing.T, tests ...Test) *Builder {
	t.Helper()
	ctx := &Builder{
		imp: localImporter{pkgs: make(map[string]importers.Package)},
	}
	ctx.Continue(t, tests...)
	return ctx
}

// Continue running tests with the same builder.
func (b *Builder) Continue(t *testing.T, tests ...Test) {
	for _, test := range tests {
		if _, ok := test.(DeclarePackage); ok {
			if err := test.Run(b); err != nil {
				t.Fatal(err)
			}
		}
		t.Run(b.nextTestName(), func(t *testing.T) {
			t.Helper()
			if err := test.Run(b); err != nil {
				t.Errorf("\n%s\n%+v", test.Source(), fmterr.ToStackTraceError(err))
			}
		})
	}
}
