// Package rand implements pseudo-random number generators.
//
// The API is inspired from https://pkg.go.dev/math/rand/v2
package rand

import (
	"dtype"
	"math"
)

type bootstrapGenerator struct{}

func newBootstrapGenerator(seed int64) bootstrapGenerator

func (bootstrapGenerator) next() uint64

// New returns random values by transforming random values generated by src.
func New(src Philox) Rand {
	return Rand{src: src}
}

// NewSource returns a new source for a random generator using a seed.
func NewSource(seed int64) Philox {
	seq := newBootstrapGenerator(seed)
	return NewPhilox([3]uint64{
		seq.next(),
		seq.next(),
		seq.next(),
	})
}

// Rand is a source of random number.
type Rand struct {
	src Philox
}

// Bool returns pseudo-random boolean values as an array of bool.
func (rnd Rand) Bool(dims []intlen) (Rand, [dims___]bool) {
	src, vals := rnd.src.Uint32(dims)
	return Rand{src: src}, vals > (math.MaxUint32 / 2)
}

// Uint32 returns pseudo-random 32-bit values as an array of uint32.
func (rnd Rand) Uint32(dims []intlen) (Rand, [dims___]uint32) {
	src, vals := rnd.src.Uint32(dims)
	return Rand{src: src}, vals
}

// Uint64 returns pseudo-random 64-bit values as an array of uint64.
func (rnd Rand) Uint64(dims []intlen) (Rand, [dims___]uint64) {
	src, vals := rnd.src.Uint64(dims)
	return Rand{src: src}, vals
}

// Int32 returns pseudo-random 32-bit values as an array of int32.
func (rnd Rand) Int32(dims []intlen) (Rand, [dims___]int32) {
	src, vals := rnd.src.Uint64(dims)
	return Rand{src: src}, [...]int32(vals)
}

// Int64 returns pseudo-random 64-bit values as an array of int64.
func (rnd Rand) Int64(dims []intlen) (Rand, [dims___]int64) {
	src, vals := rnd.src.Uint64(dims)
	return Rand{src: src}, [...]int64(vals)
}

// Float64MinMax samples uniform pseudo-random values in [min, max).
func (rnd Rand) Float64MinMax(min, max float64, dims []intlen) (Rand, [dims___]float64) {
	nbits, nmant := 64, 52

	// Emulate JAX: The strategy here is to randomize only the mantissa bits with an exponent of
	// 1 (after applying the bias), then shift and scale to the desired range.
	rnd, bits := rnd.Uint64(dims)
	float_bits := (bits >> uint64(nbits - nmant)) | dtype.Reinterpret[uint64, float64](float64(1.0))
	floats := dtype.Reinterpret[float64, uint64](float_bits) - 1.0
	return rnd, math.Max(floats * (max - min) + min, min)
}

// Float64 returns pseudo-random values as an array of float64
// uniformly distributed from [0.0, 1.0) (1.0 being excluded).
func (rnd Rand) Float64(dims []intlen) (Rand, [dims___]float64) {
	return rnd.Float64MinMax(0.0, 1.0, dims)
}

// Float32MinMax samples uniform pseudo-random values in [min, max).
func (rnd Rand) Float32MinMax(min, max float32, dims []intlen) (Rand, [dims___]float32) {
	nbits, nmant := 32, 23

	// Emulate JAX: The strategy here is to randomize only the mantissa bits with an exponent of
	// 1 (after applying the bias), then shift and scale to the desired range.
	rnd, bits := rnd.Uint32(dims)
	float_bits := (bits >> uint32(nbits - nmant)) | dtype.Reinterpret[uint32, float32](float32(1.0))
	floats := dtype.Reinterpret[float32, uint32](float_bits) - 1.0
	return rnd, math.Max(floats * (max - min) + min, min)
}

// Float32 returns pseudo-random values as an array of float32
// uniformly distributed from [0.0, 1.0) (1.0 being excluded).
func (rnd Rand) Float32(dims []intlen) (Rand, [dims___]float32) {
	return rnd.Float32MinMax(0.0, 1.0, dims)
}
