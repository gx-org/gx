// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/local/google/home/degris/Temp/gx/golang/binder/cgx/cgx.go:1:1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cgx provides an interface for calling into GX from C.
package cgx

import (
	"fmt"
	"runtime"
	"strings"
	"sync/atomic"
	"unsafe"

	"github.com/gx-org/backend/dtype"
	"github.com/gx-org/backend/platform"
	"github.com/gx-org/backend/shape"
	"github.com/gx-org/gx/api"
	"github.com/gx-org/gx/api/options"
	"github.com/gx-org/gx/api/tracer"
	"github.com/gx-org/gx/api/values"
	"github.com/gx-org/gx/base/sync"
	"github.com/gx-org/gx/build/builder"
	"github.com/gx-org/gx/build/ir"
	"github.com/gx-org/gx/golang/backend/kernels"
	"github.com/gx-org/gx/golang/binder/gobindings/types"
	"github.com/pkg/errors"
)

/*
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "cgx.h"

// cgx_device_get_result is the return value for cgx_device_get().
struct cgx_device_get_result {
	cgx_device device;
	cgx_error error;
};

// cgx_list_functions_result is the return value when listing functions of a GX element.
struct cgx_list_functions_result {
	cgx_function* funcs;
	int num_functions;
	cgx_error error;
};

// cgx_function_signature_element describes a function parameter or return value.
struct cgx_function_signature_element {
	const char* name;
	enum cgx_value_kind kind;
};

// cgx_function_signature_result is the return value for cgx_function_signature().
struct cgx_function_signature_result {
	struct cgx_function_signature_element* parameter;
	uint32_t parameter_size;
	struct cgx_function_signature_element* result;
	uint32_t result_size;

	cgx_error error;
};

// cgx_interface_find_result is the return value for cgx_interface_find().
struct cgx_interface_find_result {
	cgx_interface iface;
	cgx_error error;
};

// cgx_function_find_result is the return value for cgx_function_find().
struct cgx_function_find_result {
	cgx_function function;
	cgx_error error;
};

// cgx_function_run_result is the return value for cgx_function_run().
struct cgx_function_run_result {
	cgx_value* values;
	uint32_t value_size;
	cgx_error error;
};

// cgx_value_new_result is the return value for cgx_value_new_*().
struct cgx_value_new_result {
	cgx_value value;
	cgx_error error;
};

// cgx_value_host_buffer_result is the return value for cgx_value_host_buffer().
struct cgx_value_host_buffer_result {
	cgx_host_buffer buffer;
	cgx_error error;
};

// cgx_value_get_struct_result is the return value for cgx_value_get_struct.
struct cgx_value_get_struct_result {
	cgx_struct strct;
	cgx_error error;
};

// cgx_struct_field_element describes a structure field.
struct cgx_struct_field_element {
	const char* name;
	enum cgx_value_kind kind;
};

// cgx_struct_field_list_result is the return value for cgx_struct_field_list().
struct cgx_struct_field_list_result {
	struct cgx_struct_field_element* field;
	uint32_t field_size;

	cgx_error error;
};

// cgx_shape_axes_result is the return value for cgx_shape_axes().
struct cgx_shape_axes_result {
	const int64_t* axis_lengths;
	uint32_t num_axes;
	cgx_error error;
};
*/
import _ "unsafe"

// Since uintptr cannot be negative, each of these statements will trigger a compile-time error iff
// the first type is smaller than the second type.
const (
	// Ensure C.int64_t and Go int are the same size.
	_ = unsafe.Sizeof( /*line :140:20*/_Ctype_int64_t /*line :140:29*/(0)) - unsafe.Sizeof(int(0))
	_ = unsafe.Sizeof(int(0)) - unsafe.Sizeof( /*line :141:44*/_Ctype_int64_t /*line :141:53*/(0))

	// Ensure C.int64_t and Go uintptr are the same size.
	_ = unsafe.Sizeof( /*line :144:20*/_Ctype_int64_t /*line :144:29*/(0)) - unsafe.Sizeof(uintptr(0))
	_ = unsafe.Sizeof(uintptr(0)) - unsafe.Sizeof( /*line :145:48*/_Ctype_int64_t /*line :145:57*/(0))
)

// Memory visible outside Go.
var (
	// handles holds the mapping between C.cgx_handle and Go values. Implementation is borrowed from
	// "runtime/cgo"; we copy it here to allow inspecting the contents of this map.
	handles   = sync.Map[handle, any]{}
	handleIdx = atomic.Uintptr{}

	// pinners holds runtime.Pinners that are used to temporarily pin data in place so it becomes
	// accessible to C.
	pinners = sync.Map[unsafe.Pointer, *runtime.Pinner]{}
)

type handle uintptr

// Wrap converts a Go value to a cgx_handle.
//
// Handles must be unwrapped with the Unwrap() function using the same type T.
func Wrap[T comparable](v T)  /*line :165:30*/_Ctype_cgx_handle /*line :165:42*/ {
	var zero T
	if v == zero {
		return 0
	}

	h := handle(handleIdx.Add(1))
	if h == 0 {
		panic("cgx: ran out of handle space")
	}

	handles.Store(h, v)
	return  /*line :177:9*/_Ctype_cgx_handle /*line :177:21*/(h)
}

// Unwrap converts a handle returned by Wrap() into the original Go value.
//
// Unwrap() must be called with the same type T used in the original Wrap() call.
func Unwrap[T any](h  /*line :183:22*/_Ctype_cgx_handle /*line :183:34*/) T {
	if h == 0 {
		var zero T
		return zero
	}
	return handles.Load(handle(h)).(T)
}

// ToHandle coerces a handle value to C.cgx_handle for the benefit of Go code outside the cgx package.
func ToHandle(h uintptr)  /*line :192:26*/_Ctype_cgx_handle /*line :192:38*/ {
	return  /*line :193:9*/_Ctype_cgx_handle /*line :193:21*/(h)
}

// Release deletes a cgx handle.
//
// The handle must not be used (either through Unwrap or Release) after deletion.
func Release(h  /*line :199:16*/_Ctype_cgx_handle /*line :199:28*/) {
	if h != 0 {
		_, ok := handles.LoadAndDelete(handle(h))
		if !ok {
			panic("cgx: deleting invalid handle")
		}
	}
}

//export cgx_release_reference
func cgx_release_reference(handle  /*line :209:35*/_Ctype_cgx_handle /*line :209:47*/) uintptr {
	Release(handle)
	if handles.Empty() {
		// Force garbage collection when the final CGX reference is released; this is mostly for the
		// benefit of tests which may have leak detection enabled.
		runtime.GC()
	}
	return 0
}

//export cgx_release_references
func cgx_release_references(ptr * /*line :220:34*/_Ctype_cgx_handle /*line :220:46*/, size  /*line :220:53*/_Ctype_uint32_t /*line :220:63*/) uintptr {
	refs := unsafe.Slice(ptr, size)
	for i, ref := range refs {
		cgx_release_reference(ref)
		refs[i] = 0
	}
	return 0
}

// WrapSlice wraps all the elements of a slice into C handles.
func WrapSlice[T comparable](vs []T) [] /*line :230:40*/_Ctype_cgx_handle /*line :230:52*/ {
	if len(vs) == 0 {
		return nil
	}
	refs := make([] /*line :234:17*/_Ctype_cgx_handle /*line :234:29*/, len(vs))
	for i, v := range vs {
		refs[i] = Wrap[T](v)
	}
	return refs
}

// pinSliceData pins the content of a slice so that it can shared with C.
// Call unpinSliceData to release the reference to the slice data.
func pinSliceData[T any](vs []T) unsafe.Pointer {
	if vs == nil {
		return nil
	}
	ptr := unsafe.Pointer(unsafe.SliceData(vs))
	pinner := runtime.Pinner{}
	pinner.Pin(ptr)
	pinners.Store(ptr, &pinner)
	return ptr
}

// unpinSliceData unpin the data of a slice.
func unpinSliceData(ptr unsafe.Pointer) {
	if ptr == nil {
		return
	}
	pinner := pinners.Load(ptr)
	pinner.Unpin()
	pinners.Delete(ptr)
}

// copyPrimitiveSlice returns a copy of the slice described by `data` and `size`.
func copyPrimitiveSlice[T any](data unsafe.Pointer, size int) []T {
	return append([]T{}, unsafe.Slice((*T)(data), size)...)
}

/* cgx_handle */

// HandleCount returns the total number of active handles and pinned slices.
func HandleCount() int {
	return handles.Size() + pinners.Size()
}

// cgx_handle_count returns the number of outstanding handles.
//
// For testing only.
//
//export cgx_handle_count
func cgx_handle_count()  /*line :281:25*/_Ctype_int64_t /*line :281:34*/ {
	return  /*line :282:9*/_Ctype_int64_t /*line :282:18*/(HandleCount())
}

// HandleDump returns a string representation of all existing handles and pinned slices.
func HandleDump() string {
	s := strings.Builder{}
	for h, v := range handles.Iter() {
		s.WriteString(fmt.Sprintf("%T handle: %v\n", v, h))
	}
	for ptr := range pinners.Iter() {
		s.WriteString(fmt.Sprintf("slice: %p\n", ptr))
	}
	return s.String()
}

// cgx_handle_dump returns a full list of all outstanding handles.
//
// For testing only.
//
//export cgx_handle_dump
func cgx_handle_dump() * /*line :302:25*/_Ctype_cchar_t /*line :302:34*/ {
	return ( /*line :303:9*/_Cfunc_CString /*line :303:17*/)(HandleDump())
}

/* cgx_error */

// Errorf formats according to a format specifier and returns the new error via cgx_error handle.
func Errorf(fmt string, args ...any)  /*line :309:38*/_Ctype_cgx_error /*line :309:49*/ {
	return ( /*line :310:10*/_Ctype_cgx_error /*line :310:21*/)(Wrap[error](errors.Errorf(fmt, args...)))
}

//export cgx_error_message
func cgx_error_message(cgxError  /*line :314:33*/_Ctype_cgx_error /*line :314:44*/) * /*line :314:47*/_Ctype_cchar_t /*line :314:56*/ {
	err := Unwrap[error](cgxError)
	return ( /*line :316:9*/_Cfunc_CString /*line :316:17*/)(err.Error())
}

//export cgx_error_debug_message
func cgx_error_debug_message(cgxError  /*line :320:39*/_Ctype_cgx_error /*line :320:50*/) * /*line :320:53*/_Ctype_cchar_t /*line :320:62*/ {
	err := Unwrap[error](cgxError)
	return ( /*line :322:9*/_Cfunc_CString /*line :322:17*/)(fmt.Sprintf("%+v\n", err))
}

/* cgx_device */

//export cgx_device_get
func cgx_device_get(cgxRuntime  /*line :328:32*/_Ctype_cgx_runtime /*line :328:45*/, deviceIdx int)  /*line :328:62*/_Ctype_struct_cgx_device_get_result /*line :328:92*/ {
	rtm := Unwrap[*api.Runtime](cgxRuntime)
	dev, err := rtm.Device(deviceIdx)
	if err != nil {
		return  /*line :332:10*/_Ctype_struct_cgx_device_get_result /*line :332:40*/{
			error: ( /*line :333:12*/_Ctype_cgx_error /*line :333:23*/)(Wrap[error](err)),
		}
	}
	return  /*line :336:9*/_Ctype_struct_cgx_device_get_result /*line :336:39*/{
		device: ( /*line :337:12*/_Ctype_cgx_device /*line :337:24*/)(Wrap[*api.Device](dev)),
	}
}

//export cgx_device_get_runtime
func cgx_device_get_runtime(cgxDevice  /*line :342:39*/_Ctype_cgx_device /*line :342:51*/)  /*line :342:53*/_Ctype_cgx_runtime /*line :342:66*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return ( /*line :344:10*/_Ctype_cgx_runtime /*line :344:23*/)(Wrap[*api.Runtime](dev.Runtime()))
}

/* cgx_package_ir */

//export cgx_package_ir_load
func cgx_package_ir_load(cgxRuntime  /*line :350:37*/_Ctype_cgx_runtime /*line :350:50*/, pathPtr * /*line :350:61*/_Ctype_cchar_t /*line :350:70*/)  /*line :350:72*/_Ctype_struct_cgx_package_ir_load_result /*line :350:107*/ {
	rtm := Unwrap[*api.Runtime](cgxRuntime)
	pkg, err := rtm.Builder().Build(( /*line :352:34*/_Cfunc_GoString /*line :352:43*/)(pathPtr))
	return  /*line :353:9*/_Ctype_struct_cgx_package_ir_load_result /*line :353:44*/{
		error:    ( /*line :354:14*/_Ctype_cgx_error /*line :354:25*/)(Wrap[error](err)),
		_package: ( /*line :355:14*/_Ctype_cgx_package_ir /*line :355:30*/)(Wrap[builder.Package](pkg)),
	}
}

/* cgx_package */

type packageHandle struct {
	dev *api.Device
	pkg builder.Package
}

func newPackageHandle(dev *api.Device, pkg builder.Package) *packageHandle {
	if pkg == nil {
		return nil
	}
	return &packageHandle{
		pkg: pkg,
		dev: dev,
	}
}

// NewPackageHandle returns a new C handle to compile a package for a runtime and a device.
// The returned value always has type C.cgx_package.
func NewPackageHandle(dev *api.Device, pkg builder.Package)  /*line :378:61*/_Ctype_cgx_handle /*line :378:73*/ {
	return Wrap[*packageHandle](newPackageHandle(dev, pkg))
}

//export cgx_package_ir_build_for
func cgx_package_ir_build_for(cgxPackageIR  /*line :383:44*/_Ctype_cgx_package_ir /*line :383:60*/, cgxDevice  /*line :383:72*/_Ctype_cgx_device /*line :383:84*/)  /*line :383:86*/_Ctype_cgx_package /*line :383:99*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	pkg := Unwrap[builder.Package](cgxPackageIR)
	return  /*line :386:9*/_Ctype_cgx_package /*line :386:22*/(NewPackageHandle(dev, pkg))
}

//export cgx_package_ir_name
func cgx_package_ir_name(cgxPackageIR  /*line :390:39*/_Ctype_cgx_package_ir /*line :390:55*/) * /*line :390:58*/_Ctype_cchar_t /*line :390:67*/ {
	pkg := Unwrap[builder.Package](cgxPackageIR)
	return ( /*line :392:9*/_Cfunc_CString /*line :392:17*/)(pkg.IR().Name.Name)
}

//export cgx_package_ir_fullname
func cgx_package_ir_fullname(cgxPackageIR  /*line :396:43*/_Ctype_cgx_package_ir /*line :396:59*/) * /*line :396:62*/_Ctype_cchar_t /*line :396:71*/ {
	pkg := Unwrap[builder.Package](cgxPackageIR)
	return ( /*line :398:9*/_Cfunc_CString /*line :398:17*/)(pkg.IR().FullName())
}

//export cgx_package_list_functions
func cgx_package_list_functions(cgxPackage  /*line :402:44*/_Ctype_cgx_package /*line :402:57*/)  /*line :402:59*/_Ctype_struct_cgx_list_functions_result /*line :402:93*/ {
	cpkg := Unwrap[*packageHandle](cgxPackage)
	var funcs []*functionHandle
	for fn := range cpkg.pkg.IR().ExportedFuncs() {
		funcs = append(funcs, newFunctionHandle(cpkg.dev, fn))
	}
	return  /*line :408:9*/_Ctype_struct_cgx_list_functions_result /*line :408:43*/{
		funcs:         (* /*line :409:20*/_Ctype_cgx_function /*line :409:34*/)(pinSliceData(WrapSlice(funcs))),
		num_functions:  /*line :410:18*/_Ctype_int /*line :410:23*/(len(funcs)),
	}
}

//export cgx_package_get_ir
func cgx_package_get_ir(cgxPackage  /*line :415:36*/_Ctype_cgx_package /*line :415:49*/)  /*line :415:51*/_Ctype_cgx_package_ir /*line :415:67*/ {
	cpkg := Unwrap[*packageHandle](cgxPackage)
	return ( /*line :417:10*/_Ctype_cgx_package_ir /*line :417:26*/)(Wrap[builder.Package](cpkg.pkg))
}

//export cgx_free_list_functions_result
func cgx_free_list_functions_result(res * /*line :421:42*/_Ctype_struct_cgx_list_functions_result /*line :421:76*/) {
	unpinSliceData(unsafe.Pointer(res.funcs))
	res.funcs = nil
	res.num_functions = 0
}

//export cgx_interface_find
func cgx_interface_find(cgxPackage  /*line :428:36*/_Ctype_cgx_package /*line :428:49*/, cname * /*line :428:58*/_Ctype_cchar_t /*line :428:67*/) (res  /*line :428:74*/_Ctype_struct_cgx_interface_find_result /*line :428:108*/) {
	cpkg := Unwrap[*packageHandle](cgxPackage)
	name := ( /*line :430:10*/_Cfunc_GoString /*line :430:19*/)(cname)
	irPkg := cpkg.pkg.IR()
	for _, typ := range irPkg.ExportedTypes() {
		if typ.Name() == name {
			res.iface = ( /*line :434:17*/_Ctype_cgx_interface /*line :434:32*/)(Wrap[*interfaceHandle](newInterfaceHandle(cpkg.dev, typ)))
			return
		}
	}
	res.error = Errorf("type %q not found in package %q", name, irPkg.Name.String())
	return
}

/* cgx_function */

type functionHandle struct {
	dev   *api.Device
	fn    ir.Func
	graph tracer.CompiledFunc
}

func newFunctionHandle(dev *api.Device, fn ir.Func) *functionHandle {
	if dev == nil {
		panic("nil device")
	}
	return &functionHandle{dev: dev, fn: fn}
}

func (f *functionHandle) compile(receiver values.Value, args []values.Value, options []options.PackageOption) (err error) {
	fDecl, ok := f.fn.(*ir.FuncDecl)
	if !ok {
		return errors.Errorf("cannot run %s.%s: builtin functions not supported", f.fn.File().Package.Name.Name, f.fn.Name())
	}
	f.graph, err = tracer.Trace(f.dev, fDecl, receiver, args, options)
	return
}

//export cgx_function_find
func cgx_function_find(cgxPackage  /*line :467:35*/_Ctype_cgx_package /*line :467:48*/, funcNamePtr * /*line :467:63*/_Ctype_cchar_t /*line :467:72*/) (res  /*line :467:79*/_Ctype_struct_cgx_function_find_result /*line :467:112*/) {
	cpkg := Unwrap[*packageHandle](cgxPackage)
	name := ( /*line :469:10*/_Cfunc_GoString /*line :469:19*/)(funcNamePtr)
	if !ir.IsExported(name) {
		res.error = Errorf("function %q not exported", name)
		return
	}
	irPkg := cpkg.pkg.IR()
	fun := irPkg.FindFunc(name)
	if fun == nil {
		res.error = Errorf("function %q not found in package %q", name, irPkg.Name)
		return
	}
	res.function = ( /*line :480:18*/_Ctype_cgx_function /*line :480:32*/)(Wrap[*functionHandle](newFunctionHandle(cpkg.dev, fun)))
	return
}

//export cgx_function_run
func cgx_function_run(cgxFunction  /*line :485:35*/_Ctype_cgx_function /*line :485:49*/, cgxReceiver  /*line :485:63*/_Ctype_cgx_value /*line :485:74*/, argCount  /*line :485:85*/_Ctype_int /*line :485:90*/, args * /*line :485:98*/_Ctype_cgx_value /*line :485:109*/)  /*line :485:111*/_Ctype_struct_cgx_function_run_result /*line :485:143*/ {
	function := Unwrap[*functionHandle](cgxFunction)
	recvValue := Unwrap[values.Value](cgxReceiver)
	cgxValues := unsafe.Slice(args, argCount)
	argValues := make([]values.Value, int(argCount))
	for i, cgxValue := range cgxValues {
		argValues[i] = Unwrap[values.Value](cgxValue)
	}
	// If we haven't built a compiled graph yet, do so and cache it in the function handle.
	if function.graph == nil {
		if err := function.compile(recvValue, argValues, nil); err != nil {
			return  /*line :496:11*/_Ctype_struct_cgx_function_run_result /*line :496:43*/{error: ( /*line :496:52*/_Ctype_cgx_error /*line :496:63*/)(Wrap[error](err))}
		}
	}
	results, err := function.graph.Run(recvValue, argValues, nil)
	if err != nil {
		return  /*line :501:10*/_Ctype_struct_cgx_function_run_result /*line :501:42*/{error: ( /*line :501:51*/_Ctype_cgx_error /*line :501:62*/)(Wrap[error](err))}
	}
	return  /*line :503:9*/_Ctype_struct_cgx_function_run_result /*line :503:41*/{
		values:     (* /*line :504:17*/_Ctype_cgx_value /*line :504:28*/)(pinSliceData(WrapSlice(results))),
		value_size:  /*line :505:15*/_Ctype_uint32_t /*line :505:25*/(len(results)),
	}
}

//export cgx_function_name
func cgx_function_name(cgxFunction  /*line :510:36*/_Ctype_cgx_function /*line :510:50*/) * /*line :510:53*/_Ctype_cchar_t /*line :510:62*/ {
	function := Unwrap[*functionHandle](cgxFunction)
	return ( /*line :512:9*/_Cfunc_CString /*line :512:17*/)(function.fn.Name())
}

//export cgx_function_doc
func cgx_function_doc(cgxFunction  /*line :516:35*/_Ctype_cgx_function /*line :516:49*/) * /*line :516:52*/_Ctype_cchar_t /*line :516:61*/ {
	function := Unwrap[*functionHandle](cgxFunction)
	return ( /*line :518:9*/_Cfunc_CString /*line :518:17*/)(function.fn.Doc().Text())
}

func copySignatureElements(fields *ir.FieldList) * /*line :521:51*/_Ctype_struct_cgx_function_signature_element /*line :521:90*/ {
	elements := make([] /*line :522:21*/_Ctype_struct_cgx_function_signature_element /*line :522:60*/, fields.Len())
	for n, field := range fields.Fields() {
		elements[n].name = ( /*line :524:22*/_Cfunc_CString /*line :524:30*/)(field.Name.String())
		elements[n].kind = toCGXValueKind(field.Type().Kind())
	}
	return (* /*line :527:11*/_Ctype_struct_cgx_function_signature_element /*line :527:50*/)(pinSliceData(elements))
}

//export cgx_function_signature
func cgx_function_signature(cgxFunction  /*line :531:41*/_Ctype_cgx_function /*line :531:55*/)  /*line :531:57*/_Ctype_struct_cgx_function_signature_result /*line :531:95*/ {
	function := Unwrap[*functionHandle](cgxFunction)
	result :=  /*line :533:12*/_Ctype_struct_cgx_function_signature_result /*line :533:50*/{
		parameter:      copySignatureElements(function.fn.FuncType().Params),
		parameter_size:  /*line :535:19*/_Ctype_uint32_t /*line :535:29*/(function.fn.FuncType().Params.Len()),
		result:         copySignatureElements(function.fn.FuncType().Results),
		result_size:     /*line :537:19*/_Ctype_uint32_t /*line :537:29*/(function.fn.FuncType().Results.Len()),
	}
	return result
}

//export cgx_free_function_signature_result
func cgx_free_function_signature_result(cgxSignature * /*line :543:55*/_Ctype_struct_cgx_function_signature_result /*line :543:93*/) {
	freeSignature := func(list * /*line :544:30*/_Ctype_struct_cgx_function_signature_element /*line :544:69*/, size  /*line :544:76*/_Ctype_uint32_t /*line :544:86*/) {
		for _, item := range unsafe.Slice(list, size) {
			func() { _cgo0 := /*line :546:11*/unsafe.Pointer(item.name); _cgoCheckPointer(_cgo0, nil); /*line :546:37*/_Cfunc_free(_cgo0); }()
		}
		unpinSliceData(unsafe.Pointer(list))
	}
	freeSignature(cgxSignature.parameter, cgxSignature.parameter_size)
	cgxSignature.parameter = nil
	cgxSignature.parameter_size = 0
	freeSignature(cgxSignature.result, cgxSignature.result_size)
	cgxSignature.result = nil
	cgxSignature.result_size = 0
}

//export cgx_function_num_params
func cgx_function_num_params(cgxFunction  /*line :559:42*/_Ctype_cgx_function /*line :559:56*/) int {
	function := Unwrap[*functionHandle](cgxFunction)
	return function.fn.FuncType().Params.Len()
}

//export cgx_function_param_dtype
func cgx_function_param_dtype(cgxFunction  /*line :565:43*/_Ctype_cgx_function /*line :565:57*/, arg int)  /*line :565:68*/_Ctype_enum_cgx_value_kind /*line :565:89*/ {
	function := Unwrap[*functionHandle](cgxFunction)
	params := function.fn.FuncType().Params.Fields()
	if arg < 0 || arg >= len(params) {
		return ( /*line :569:10*/_Ciconst_CGX_INVALID /*line :569:22*/)
	}
	_, dtype := ir.Shape(params[arg].Type())
	return toCGXValueKind(dtype.Kind())
}

//export cgx_free_function_run_result
func cgx_free_function_run_result(cgxFunctionResult * /*line :576:54*/_Ctype_struct_cgx_function_run_result /*line :576:86*/) {
	unpinSliceData(unsafe.Pointer(cgxFunctionResult.values))
	cgxFunctionResult.values = nil
}

/* cgx_value */

func toValueResult[T dtype.GoDataType](devAtom *types.DeviceAtom[T], err error)  /*line :583:81*/_Ctype_struct_cgx_value_new_result /*line :583:110*/ {
	if err != nil {
		return  /*line :585:10*/_Ctype_struct_cgx_value_new_result /*line :585:39*/{error: ( /*line :585:48*/_Ctype_cgx_error /*line :585:59*/)(Wrap[error](err))}
	}
	return  /*line :587:9*/_Ctype_struct_cgx_value_new_result /*line :587:38*/{
		value: ( /*line :588:11*/_Ctype_cgx_value /*line :588:22*/)(Wrap[values.Value](devAtom.GXValue())),
	}
}

//export cgx_value_new_bool
func cgx_value_new_bool(cgxDevice  /*line :593:35*/_Ctype_cgx_device /*line :593:47*/, value  /*line :593:55*/_Ctype_bool /*line :593:61*/)  /*line :593:63*/_Ctype_struct_cgx_value_new_result /*line :593:92*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Bool(bool(value)).SendTo(dev))
}

//export cgx_value_new_float32
func cgx_value_new_float32(cgxDevice  /*line :599:38*/_Ctype_cgx_device /*line :599:50*/, value  /*line :599:58*/_Ctype_float /*line :599:65*/)  /*line :599:67*/_Ctype_struct_cgx_value_new_result /*line :599:96*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Float32(float32(value)).SendTo(dev))
}

//export cgx_value_new_float64
func cgx_value_new_float64(cgxDevice  /*line :605:38*/_Ctype_cgx_device /*line :605:50*/, value  /*line :605:58*/_Ctype_double /*line :605:66*/)  /*line :605:68*/_Ctype_struct_cgx_value_new_result /*line :605:97*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Float64(float64(value)).SendTo(dev))
}

//export cgx_value_new_int32
func cgx_value_new_int32(cgxDevice  /*line :611:36*/_Ctype_cgx_device /*line :611:48*/, value  /*line :611:56*/_Ctype_int32_t /*line :611:65*/)  /*line :611:67*/_Ctype_struct_cgx_value_new_result /*line :611:96*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Int32(int32(value)).SendTo(dev))
}

//export cgx_value_new_int64
func cgx_value_new_int64(cgxDevice  /*line :617:36*/_Ctype_cgx_device /*line :617:48*/, value  /*line :617:56*/_Ctype_int64_t /*line :617:65*/)  /*line :617:67*/_Ctype_struct_cgx_value_new_result /*line :617:96*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Int64(int64(value)).SendTo(dev))
}

//export cgx_value_new_uint32
func cgx_value_new_uint32(cgxDevice  /*line :623:37*/_Ctype_cgx_device /*line :623:49*/, value  /*line :623:57*/_Ctype_uint32_t /*line :623:67*/)  /*line :623:69*/_Ctype_struct_cgx_value_new_result /*line :623:98*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Uint32(uint32(value)).SendTo(dev))
}

//export cgx_value_new_uint64
func cgx_value_new_uint64(cgxDevice  /*line :629:37*/_Ctype_cgx_device /*line :629:49*/, value  /*line :629:57*/_Ctype_uint64_t /*line :629:67*/)  /*line :629:69*/_Ctype_struct_cgx_value_new_result /*line :629:98*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Uint64(uint64(value)).SendTo(dev))
}

//export cgx_value_send
func cgx_value_send(cgxDevice  /*line :635:31*/_Ctype_cgx_device /*line :635:43*/, cgxShape  /*line :635:54*/_Ctype_cgx_shape /*line :635:65*/, data * /*line :635:73*/_Ctype_cvoid_t /*line :635:82*/, dataSize  /*line :635:93*/_Ctype_uint64_t /*line :635:103*/)  /*line :635:105*/_Ctype_struct_cgx_value_new_result /*line :635:134*/ {
	dev := Unwrap[*api.Device](cgxDevice)
	shape := Unwrap[*shape.Shape](cgxShape)
	byteData := (*byte)(unsafe.Pointer(data))

	handle, err := dev.PlatformDevice().Send(unsafe.Slice(byteData, dataSize), shape)
	if err != nil {
		return  /*line :642:10*/_Ctype_struct_cgx_value_new_result /*line :642:39*/{error: ( /*line :642:48*/_Ctype_cgx_error /*line :642:59*/)(Wrap[error](err))}
	}
	dataType := ir.TypeFromKind(ir.Kind(shape.DType))
	valueType := ir.NewArrayType(nil, dataType, ir.NewRank(shape.AxisLengths))
	value, err := values.NewDeviceArray(valueType, handle)
	if err != nil {
		return  /*line :648:10*/_Ctype_struct_cgx_value_new_result /*line :648:39*/{error: ( /*line :648:48*/_Ctype_cgx_error /*line :648:59*/)(Wrap[error](err))}
	}
	return  /*line :650:9*/_Ctype_struct_cgx_value_new_result /*line :650:38*/{
		value: ( /*line :651:11*/_Ctype_cgx_value /*line :651:22*/)(Wrap[values.Value](value)),
	}
}

func toCGXValueKind(kind ir.Kind)  /*line :655:35*/_Ctype_enum_cgx_value_kind /*line :655:56*/ {
	switch kind {
	case ir.BoolKind:
		return ( /*line :658:10*/_Ciconst_CGX_BOOL /*line :658:19*/)
	case ir.Bfloat16Kind:
		return ( /*line :660:10*/_Ciconst_CGX_BFLOAT16 /*line :660:23*/)
	case ir.Float32Kind:
		return ( /*line :662:10*/_Ciconst_CGX_FLOAT32 /*line :662:22*/)
	case ir.Float64Kind:
		return ( /*line :664:10*/_Ciconst_CGX_FLOAT64 /*line :664:22*/)
	case ir.Int32Kind:
		return ( /*line :666:10*/_Ciconst_CGX_INT32 /*line :666:20*/)
	case ir.Int64Kind:
		return ( /*line :668:10*/_Ciconst_CGX_INT64 /*line :668:20*/)
	case ir.Uint32Kind:
		return ( /*line :670:10*/_Ciconst_CGX_UINT32 /*line :670:21*/)
	case ir.Uint64Kind:
		return ( /*line :672:10*/_Ciconst_CGX_UINT64 /*line :672:21*/)
	case ir.ArrayKind:
		return ( /*line :674:10*/_Ciconst_CGX_ARRAY /*line :674:20*/)
	case ir.SliceKind:
		return ( /*line :676:10*/_Ciconst_CGX_SLICE /*line :676:20*/)
	case ir.StructKind:
		return ( /*line :678:10*/_Ciconst_CGX_STRUCT /*line :678:21*/)
	default:
		return ( /*line :680:10*/_Ciconst_CGX_INVALID /*line :680:22*/)
	}
}

//export cgx_value_kind_of
func cgx_value_kind_of(cgxValue  /*line :685:33*/_Ctype_cgx_value /*line :685:44*/)  /*line :685:46*/_Ctype_enum_cgx_value_kind /*line :685:67*/ {
	value := Unwrap[values.Value](cgxValue)
	return toCGXValueKind(value.Type().Kind())
}

//export cgx_value_shape
func cgx_value_shape(cgxValue  /*line :691:31*/_Ctype_cgx_value /*line :691:42*/)  /*line :691:44*/_Ctype_cgx_shape /*line :691:55*/ {
	value := Unwrap[values.Value](cgxValue)
	if array, ok := value.(values.Array); ok {
		return ( /*line :694:11*/_Ctype_cgx_shape /*line :694:22*/)(Wrap[*shape.Shape](array.Shape()))
	}
	return 0
}

func atomFromDeviceArray[T dtype.GoDataType](cgxValue  /*line :699:55*/_Ctype_cgx_value /*line :699:66*/) T {
	value := Unwrap[values.Value](cgxValue)
	atomDevice := types.NewDeviceAtom[T](value.(*values.DeviceArray))
	atomHost, err := atomDevice.Fetch()
	if err != nil {
		panic(err)
	}
	return atomHost.Value()
}

//export cgx_value_get_bool
func cgx_value_get_bool(cgxValue  /*line :710:34*/_Ctype_cgx_value /*line :710:45*/)  /*line :710:47*/_Ctype_bool /*line :710:53*/ {
	return  /*line :711:9*/_Ctype_bool /*line :711:15*/(atomFromDeviceArray[bool](cgxValue))
}

//export cgx_value_get_float32
func cgx_value_get_float32(cgxValue  /*line :715:37*/_Ctype_cgx_value /*line :715:48*/)  /*line :715:50*/_Ctype_float /*line :715:57*/ {
	return  /*line :716:9*/_Ctype_float /*line :716:16*/(atomFromDeviceArray[float32](cgxValue))
}

//export cgx_value_get_float64
func cgx_value_get_float64(cgxValue  /*line :720:37*/_Ctype_cgx_value /*line :720:48*/)  /*line :720:50*/_Ctype_double /*line :720:58*/ {
	return  /*line :721:9*/_Ctype_double /*line :721:17*/(atomFromDeviceArray[float64](cgxValue))
}

//export cgx_value_get_int32
func cgx_value_get_int32(cgxValue  /*line :725:35*/_Ctype_cgx_value /*line :725:46*/)  /*line :725:48*/_Ctype_int32_t /*line :725:57*/ {
	return  /*line :726:9*/_Ctype_int32_t /*line :726:18*/(atomFromDeviceArray[int32](cgxValue))
}

//export cgx_value_get_int64
func cgx_value_get_int64(cgxValue  /*line :730:35*/_Ctype_cgx_value /*line :730:46*/)  /*line :730:48*/_Ctype_int64_t /*line :730:57*/ {
	return  /*line :731:9*/_Ctype_int64_t /*line :731:18*/(atomFromDeviceArray[int64](cgxValue))
}

//export cgx_value_get_uint32
func cgx_value_get_uint32(cgxValue  /*line :735:36*/_Ctype_cgx_value /*line :735:47*/)  /*line :735:49*/_Ctype_uint32_t /*line :735:59*/ {
	return  /*line :736:9*/_Ctype_uint32_t /*line :736:19*/(atomFromDeviceArray[uint32](cgxValue))
}

//export cgx_value_get_uint64
func cgx_value_get_uint64(cgxValue  /*line :740:36*/_Ctype_cgx_value /*line :740:47*/)  /*line :740:49*/_Ctype_uint64_t /*line :740:59*/ {
	return  /*line :741:9*/_Ctype_uint64_t /*line :741:19*/(atomFromDeviceArray[uint64](cgxValue))
}

//export cgx_value_host_buffer
func cgx_value_host_buffer(cgxValue  /*line :745:37*/_Ctype_cgx_value /*line :745:48*/)  /*line :745:50*/_Ctype_struct_cgx_value_host_buffer_result /*line :745:87*/ {
	value := Unwrap[values.Value](cgxValue)
	deviceArray := value.(*values.DeviceArray)
	hostArray, err := deviceArray.ToHostArray(kernels.Allocator())
	if err != nil {
		return  /*line :750:10*/_Ctype_struct_cgx_value_host_buffer_result /*line :750:47*/{}
	}
	return  /*line :752:9*/_Ctype_struct_cgx_value_host_buffer_result /*line :752:46*/{
		buffer: ( /*line :753:12*/_Ctype_cgx_host_buffer /*line :753:29*/)(Wrap[platform.HostBuffer](hostArray.Buffer())),
	}
}

//export cgx_value_get_struct
func cgx_value_get_struct(cgxValue  /*line :758:36*/_Ctype_cgx_value /*line :758:47*/)  /*line :758:49*/_Ctype_struct_cgx_value_get_struct_result /*line :758:85*/ {
	value := Unwrap[values.Value](cgxValue)
	kind := value.Type().Kind()
	if value.Type().Kind() != ir.StructKind {
		return  /*line :762:10*/_Ctype_struct_cgx_value_get_struct_result /*line :762:46*/{
			error: Errorf("value has kind %v, expect kind %v", kind, ir.StructKind),
		}
	}
	strct := values.Underlying(value).(*values.Struct)
	return  /*line :767:9*/_Ctype_struct_cgx_value_get_struct_result /*line :767:45*/{
		strct: ( /*line :768:11*/_Ctype_cgx_struct /*line :768:23*/)(Wrap[*structHandle](&structHandle{value: strct})),
	}
}

//export cgx_value_get_interface_type
func cgx_value_get_interface_type(cgxDevice  /*line :773:45*/_Ctype_cgx_device /*line :773:57*/, cgxValue  /*line :773:68*/_Ctype_cgx_value /*line :773:79*/)  /*line :773:81*/_Ctype_cgx_interface /*line :773:96*/ {
	value := Unwrap[values.Value](cgxValue)
	namedType, ok := value.Type().(*ir.NamedType)
	if !ok {
		return 0
	}
	device := Unwrap[*api.Device](cgxDevice)
	return ( /*line :780:10*/_Ctype_cgx_interface /*line :780:25*/)(Wrap[*interfaceHandle](newInterfaceHandle(device, namedType)))
}

//export cgx_value_string
func cgx_value_string(cgxValue  /*line :784:32*/_Ctype_cgx_value /*line :784:43*/) * /*line :784:46*/_Ctype_cchar_t /*line :784:55*/ {
	value := Unwrap[values.Value](cgxValue)
	return ( /*line :786:9*/_Cfunc_CString /*line :786:17*/)(value.String())
}

/* cgx_shape */

func fromCGXValueKind(valueType  /*line :791:33*/_Ctype_enum_cgx_value_kind /*line :791:54*/) dtype.DataType {
	switch valueType {
	case ( /*line :793:7*/_Ciconst_CGX_BOOL /*line :793:16*/):
		return dtype.Bool
	case ( /*line :795:7*/_Ciconst_CGX_BFLOAT16 /*line :795:20*/):
		return dtype.Bfloat16
	case ( /*line :797:7*/_Ciconst_CGX_FLOAT32 /*line :797:19*/):
		return dtype.Float32
	case ( /*line :799:7*/_Ciconst_CGX_FLOAT64 /*line :799:19*/):
		return dtype.Float64
	case ( /*line :801:7*/_Ciconst_CGX_INT32 /*line :801:17*/):
		return dtype.Int32
	case ( /*line :803:7*/_Ciconst_CGX_INT64 /*line :803:17*/):
		return dtype.Int64
	case ( /*line :805:7*/_Ciconst_CGX_UINT32 /*line :805:18*/):
		return dtype.Uint32
	case ( /*line :807:7*/_Ciconst_CGX_UINT64 /*line :807:18*/):
		return dtype.Uint64
	default:
		return dtype.Invalid
	}
}

//export cgx_shape_new
func cgx_shape_new(dtype  /*line :815:26*/_Ctype_enum_cgx_value_kind /*line :815:47*/, axisLengths * /*line :815:62*/_Ctype_cint64_t /*line :815:72*/, axisLengthsSize  /*line :815:90*/_Ctype_int /*line :815:95*/)  /*line :815:97*/_Ctype_cgx_shape /*line :815:108*/ {
	return ( /*line :816:10*/_Ctype_cgx_shape /*line :816:21*/)(Wrap[*shape.Shape](&shape.Shape{
		DType:       fromCGXValueKind(dtype),
		AxisLengths: copyPrimitiveSlice[int](unsafe.Pointer(axisLengths), int(axisLengthsSize)),
	}))
}

//export cgx_shape_axes
func cgx_shape_axes(cgxShape  /*line :823:30*/_Ctype_cgx_shape /*line :823:41*/)  /*line :823:43*/_Ctype_struct_cgx_shape_axes_result /*line :823:73*/ {
	shape := Unwrap[*shape.Shape](cgxShape)
	return  /*line :825:9*/_Ctype_struct_cgx_shape_axes_result /*line :825:39*/{
		axis_lengths: (* /*line :826:19*/_Ctype_cint64_t /*line :826:29*/)(pinSliceData[int](shape.AxisLengths)),
		num_axes:      /*line :827:17*/_Ctype_uint32_t /*line :827:27*/(len(shape.AxisLengths)),
	}
}

//export cgx_free_shape_axes_result
func cgx_free_shape_axes_result(cgxShapeResult * /*line :832:49*/_Ctype_struct_cgx_shape_axes_result /*line :832:79*/) {
	unpinSliceData(unsafe.Pointer(cgxShapeResult.axis_lengths))
	cgxShapeResult.axis_lengths = nil
	cgxShapeResult.num_axes = 0
}

//export cgx_shape_size
func cgx_shape_size(cgxShape  /*line :839:30*/_Ctype_cgx_shape /*line :839:41*/)  /*line :839:43*/_Ctype_int /*line :839:48*/ {
	shape := Unwrap[*shape.Shape](cgxShape)
	return  /*line :841:9*/_Ctype_int /*line :841:14*/(shape.Size())
}

//export cgx_shape_element_kind
func cgx_shape_element_kind(cgxShape  /*line :845:38*/_Ctype_cgx_shape /*line :845:49*/)  /*line :845:51*/_Ctype_enum_cgx_value_kind /*line :845:72*/ {
	shape := Unwrap[*shape.Shape](cgxShape)
	if shape.DType < dtype.MaxDataType {
		return toCGXValueKind(ir.Kind(shape.DType))
	}
	return ( /*line :850:9*/_Ciconst_CGX_INVALID /*line :850:21*/)
}

/* cgx_host_buffer */

//export cgx_host_buffer_acquire_data
func cgx_host_buffer_acquire_data(cgxHostBuffer  /*line :856:49*/_Ctype_cgx_host_buffer /*line :856:66*/) * /*line :856:69*/_Ctype_char /*line :856:75*/ {
	hostBuffer := Unwrap[platform.HostBuffer](cgxHostBuffer)
	data := hostBuffer.Acquire()
	return (* /*line :859:11*/_Ctype_char /*line :859:17*/)(pinSliceData[byte](data))
}

//export cgx_host_buffer_release_data
func cgx_host_buffer_release_data(cgxHostBuffer  /*line :863:49*/_Ctype_cgx_host_buffer /*line :863:66*/, data * /*line :863:74*/_Ctype_char /*line :863:80*/) {
	hostBuffer := Unwrap[platform.HostBuffer](cgxHostBuffer)
	unpinSliceData(unsafe.Pointer(data))
	hostBuffer.Release()
}

/* cgx_struct */

type structHandle struct {
	value *values.Struct
}

//export cgx_struct_field_get
func cgx_struct_field_get(cgxStruct  /*line :876:37*/_Ctype_cgx_struct /*line :876:49*/, fieldNamePtr * /*line :876:65*/_Ctype_cchar_t /*line :876:74*/) (res  /*line :876:81*/_Ctype_struct_cgx_value_new_result /*line :876:110*/) {
	handle := Unwrap[*structHandle](cgxStruct)
	fieldValue := handle.value.FieldValue(( /*line :878:40*/_Cfunc_GoString /*line :878:49*/)(fieldNamePtr))
	return  /*line :879:9*/_Ctype_struct_cgx_value_new_result /*line :879:38*/{
		value: ( /*line :880:11*/_Ctype_cgx_value /*line :880:22*/)(Wrap[values.Value](fieldValue)),
	}
}

//export cgx_struct_field_set
func cgx_struct_field_set(cgxStruct  /*line :885:37*/_Ctype_cgx_struct /*line :885:49*/, fieldNamePtr * /*line :885:65*/_Ctype_cchar_t /*line :885:74*/, cgxValue  /*line :885:85*/_Ctype_cgx_value /*line :885:96*/)  /*line :885:98*/_Ctype_cgx_error /*line :885:109*/ {
	handle := Unwrap[*structHandle](cgxStruct)
	value := Unwrap[values.Value](cgxValue)
	handle.value.SetField(( /*line :888:24*/_Cfunc_GoString /*line :888:33*/)(fieldNamePtr), value)
	return ( /*line :889:10*/_Ctype_cgx_error /*line :889:21*/)(Wrap[error](nil))
}

//export cgx_struct_field_list
func cgx_struct_field_list(cgxStruct  /*line :893:38*/_Ctype_cgx_struct /*line :893:50*/) (res  /*line :893:57*/_Ctype_struct_cgx_struct_field_list_result /*line :893:94*/) {
	handle := Unwrap[*structHandle](cgxStruct)
	fields := handle.value.StructType().Fields.Fields()
	result := make([] /*line :896:19*/_Ctype_struct_cgx_struct_field_element /*line :896:52*/, len(fields))
	for n, field := range fields {
		result[n] =  /*line :898:15*/_Ctype_struct_cgx_struct_field_element /*line :898:48*/{
			name: ( /*line :899:10*/_Cfunc_CString /*line :899:18*/)(field.Name.String()),
			kind: toCGXValueKind(field.Type().Kind()),
		}
	}
	return  /*line :903:9*/_Ctype_struct_cgx_struct_field_list_result /*line :903:46*/{
		field:      (* /*line :904:17*/_Ctype_struct_cgx_struct_field_element /*line :904:50*/)(pinSliceData(result)),
		field_size:  /*line :905:15*/_Ctype_uint32_t /*line :905:25*/(len(result)),
	}
}

//export cgx_free_struct_field_list_result
func cgx_free_struct_field_list_result(cgxFieldList * /*line :910:54*/_Ctype_struct_cgx_struct_field_list_result /*line :910:91*/) {
	for _, item := range unsafe.Slice(cgxFieldList.field, cgxFieldList.field_size) {
		func() { _cgo0 := /*line :912:10*/unsafe.Pointer(item.name); _cgoCheckPointer(_cgo0, nil); /*line :912:36*/_Cfunc_free(_cgo0); }()
	}
	unpinSliceData(unsafe.Pointer(cgxFieldList.field))
	cgxFieldList.field = nil
	cgxFieldList.field_size = 0
}

/* cgx_interface */

type interfaceHandle struct {
	device *api.Device
	typ    *ir.NamedType
}

func newInterfaceHandle(dev *api.Device, typ *ir.NamedType) *interfaceHandle {
	if dev == nil {
		panic("nil device")
	}
	return &interfaceHandle{device: dev, typ: typ}
}

//export cgx_interface_method_find
func cgx_interface_method_find(cgxIFace  /*line :934:41*/_Ctype_cgx_interface /*line :934:56*/, methodNamePtr * /*line :934:73*/_Ctype_cchar_t /*line :934:82*/) (res  /*line :934:89*/_Ctype_struct_cgx_function_find_result /*line :934:122*/) {
	iface := Unwrap[*interfaceHandle](cgxIFace)
	methodName := ( /*line :936:16*/_Cfunc_GoString /*line :936:25*/)(methodNamePtr)
	method := iface.typ.MethodByName(methodName)
	if method == nil {
		packageName := iface.typ.File.Package.Name.Name
		typeName := iface.typ.Name()
		res.error = Errorf("type %s.%s has no method %s", packageName, typeName, methodName)
		return
	}
	res.function = ( /*line :944:18*/_Ctype_cgx_function /*line :944:32*/)(Wrap[*functionHandle](newFunctionHandle(iface.device, method)))
	return
}

//export cgx_interface_name
func cgx_interface_name(cgxIFace  /*line :949:34*/_Ctype_cgx_interface /*line :949:49*/) * /*line :949:52*/_Ctype_cchar_t /*line :949:61*/ {
	iface := Unwrap[*interfaceHandle](cgxIFace)
	return ( /*line :951:9*/_Cfunc_CString /*line :951:17*/)(iface.typ.Name())
}

//export cgx_interface_package_name
func cgx_interface_package_name(cgxIFace  /*line :955:42*/_Ctype_cgx_interface /*line :955:57*/) * /*line :955:60*/_Ctype_cchar_t /*line :955:69*/ {
	iface := Unwrap[*interfaceHandle](cgxIFace)
	return ( /*line :957:9*/_Cfunc_CString /*line :957:17*/)(iface.typ.File.Package.FullName())
}

//export cgx_interface_list_methods
func cgx_interface_list_methods(cgxIFace  /*line :961:42*/_Ctype_cgx_interface /*line :961:57*/)  /*line :961:59*/_Ctype_struct_cgx_list_functions_result /*line :961:93*/ {
	iface := Unwrap[*interfaceHandle](cgxIFace)
	var funcs []*functionHandle
	for _, fn := range iface.typ.Methods {
		if !ir.IsExported(fn.Name()) {
			continue
		}
		funcs = append(funcs, newFunctionHandle(iface.device, fn))
	}
	return  /*line :970:9*/_Ctype_struct_cgx_list_functions_result /*line :970:43*/{
		funcs:         (* /*line :971:20*/_Ctype_cgx_function /*line :971:34*/)(pinSliceData(WrapSlice(funcs))),
		num_functions:  /*line :972:18*/_Ctype_int /*line :972:23*/(len(funcs)),
	}
}
