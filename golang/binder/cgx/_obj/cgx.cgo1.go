// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/runner/work/gx/gx/golang/binder/cgx/cgx.go:1:1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cgx provides an interface for calling into GX from C.
package cgx

import (
	"fmt"
	"unsafe"

	"github.com/pkg/errors"
	"github.com/gx-org/backend/dtype"
	"github.com/gx-org/backend/platform"
	"github.com/gx-org/backend/shape"
	"github.com/gx-org/gx/api"
	"github.com/gx-org/gx/api/options"
	"github.com/gx-org/gx/api/tracer"
	"github.com/gx-org/gx/api/values"
	"github.com/gx-org/gx/build/builder"
	"github.com/gx-org/gx/build/ir"
	"github.com/gx-org/gx/cgx/handle"
	"github.com/gx-org/gx/golang/backend/kernels"
	"github.com/gx-org/gx/golang/binder/gobindings/types"
)

/*
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include <gx/golang/binder/cgx/cgx.h>

// cgx_device_get_result is the return value for cgx_device_get().
struct cgx_device_get_result {
	cgx_device device;
	cgx_error error;
};

// cgx_list_functions_result is the return value when listing functions of a GX element.
struct cgx_list_functions_result {
	cgx_function* funcs;
	int num_functions;
	cgx_error error;
};

// cgx_function_signature_element describes a function parameter or return value.
struct cgx_function_signature_element {
	const char* name;
	enum cgx_value_kind kind;
};

// cgx_function_signature_result is the return value for cgx_function_signature().
struct cgx_function_signature_result {
	struct cgx_function_signature_element* parameter;
	uint32_t parameter_size;
	struct cgx_function_signature_element* result;
	uint32_t result_size;

	cgx_error error;
};

// cgx_interface_find_result is the return value for cgx_interface_find().
struct cgx_interface_find_result {
	cgx_interface iface;
	cgx_error error;
};

// cgx_function_find_result is the return value for cgx_function_find().
struct cgx_function_find_result {
	cgx_function function;
	cgx_error error;
};

// cgx_function_run_result is the return value for cgx_function_run().
struct cgx_function_run_result {
	cgx_value* values;
	uint32_t value_size;
	cgx_error error;
};

// cgx_value_new_result is the return value for cgx_value_new_*().
struct cgx_value_new_result {
	cgx_value value;
	cgx_error error;
};

// cgx_value_host_buffer_result is the return value for cgx_value_host_buffer().
struct cgx_value_host_buffer_result {
	cgx_host_buffer buffer;
	cgx_error error;
};

// cgx_value_get_struct_result is the return value for cgx_value_get_struct.
struct cgx_value_get_struct_result {
	cgx_struct strct;
	cgx_error error;
};

// cgx_struct_field_element describes a structure field.
struct cgx_struct_field_element {
	const char* name;
	enum cgx_value_kind kind;
};

// cgx_struct_field_list_result is the return value for cgx_struct_field_list().
struct cgx_struct_field_list_result {
	struct cgx_struct_field_element* field;
	uint32_t field_size;

	cgx_error error;
};

// cgx_shape_axes_result is the return value for cgx_shape_axes().
struct cgx_shape_axes_result {
	const int64_t* axis_lengths;
	uint32_t num_axes;
	cgx_error error;
};
*/
import _ "unsafe"

// Since uintptr cannot be negative, each of these statements will trigger a compile-time error iff
// the first type is smaller than the second type.
const (
	// Ensure C.int64_t and Go int are the same size.
	_ = unsafe.Sizeof( /*line :137:20*/_Ctype_int64_t /*line :137:29*/(0)) - unsafe.Sizeof(int(0))
	_ = unsafe.Sizeof(int(0)) - unsafe.Sizeof( /*line :138:44*/_Ctype_int64_t /*line :138:53*/(0))

	// Ensure C.int64_t and Go uintptr are the same size.
	_ = unsafe.Sizeof( /*line :141:20*/_Ctype_int64_t /*line :141:29*/(0)) - unsafe.Sizeof(uintptr(0))
	_ = unsafe.Sizeof(uintptr(0)) - unsafe.Sizeof( /*line :142:48*/_Ctype_int64_t /*line :142:57*/(0))
)

//export cgx_release_reference
func cgx_release_reference(h  /*line :146:30*/_Ctype_cgx_handle /*line :146:42*/) uintptr {
	handle.Release(handle.Handle(h))
	return 0
}

//export cgx_release_references
func cgx_release_references(ptr * /*line :152:34*/_Ctype_cgx_handle /*line :152:46*/, size  /*line :152:53*/_Ctype_uint32_t /*line :152:63*/) uintptr {
	refs := unsafe.Slice(ptr, size)
	for i, ref := range refs {
		cgx_release_reference(ref)
		refs[i] = 0
	}
	return 0
}

/* Helper local functions */

func wrap[T comparable](v T)  /*line :163:30*/_Ctype_cgx_handle /*line :163:42*/ {
	return  /*line :164:9*/_Ctype_cgx_handle /*line :164:21*/(handle.Wrap[T](v))
}

func unwrap[T any](h  /*line :167:22*/_Ctype_cgx_handle /*line :167:34*/) T {
	return handle.Unwrap[T](handle.Handle(h))
}

// copyPrimitiveSlice returns a copy of the slice described by `data` and `size`.
func copyPrimitiveSlice[T any](data unsafe.Pointer, size int) []T {
	return append([]T{}, unsafe.Slice((*T)(data), size)...)
}

/* cgx_handle */

// cgx_handle_count returns the number of outstanding handles.
//
// For testing only.
//
//export cgx_handle_count
func cgx_handle_count()  /*line :183:25*/_Ctype_int64_t /*line :183:34*/ {
	return  /*line :184:9*/_Ctype_int64_t /*line :184:18*/(handle.Count())
}

// cgx_handle_dump returns a full list of all outstanding handles.
//
// For testing only.
//
//export cgx_handle_dump
func cgx_handle_dump() * /*line :192:25*/_Ctype_cchar_t /*line :192:34*/ {
	return ( /*line :193:9*/_Cfunc_CString /*line :193:17*/)(handle.Dump())
}

/* cgx_error */

// Errorf formats according to a format specifier and returns the new error via cgx_error handle.
func Errorf(fmt string, args ...any)  /*line :199:38*/_Ctype_cgx_error /*line :199:49*/ {
	return ( /*line :200:10*/_Ctype_cgx_error /*line :200:21*/)(wrap[error](errors.Errorf(fmt, args...)))
}

//export cgx_error_message
func cgx_error_message(cgxError  /*line :204:33*/_Ctype_cgx_error /*line :204:44*/) * /*line :204:47*/_Ctype_cchar_t /*line :204:56*/ {
	err := unwrap[error](cgxError)
	return ( /*line :206:9*/_Cfunc_CString /*line :206:17*/)(err.Error())
}

//export cgx_error_debug_message
func cgx_error_debug_message(cgxError  /*line :210:39*/_Ctype_cgx_error /*line :210:50*/) * /*line :210:53*/_Ctype_cchar_t /*line :210:62*/ {
	err := unwrap[error](cgxError)
	return ( /*line :212:9*/_Cfunc_CString /*line :212:17*/)(fmt.Sprintf("%+v\n", err))
}

/* cgx_device */

//export cgx_device_get
func cgx_device_get(cgxRuntime  /*line :218:32*/_Ctype_cgx_runtime /*line :218:45*/, deviceIdx int)  /*line :218:62*/_Ctype_struct_cgx_device_get_result /*line :218:92*/ {
	rtm := unwrap[*api.Runtime](cgxRuntime)
	dev, err := rtm.Device(deviceIdx)
	if err != nil {
		return  /*line :222:10*/_Ctype_struct_cgx_device_get_result /*line :222:40*/{
			error: ( /*line :223:12*/_Ctype_cgx_error /*line :223:23*/)(wrap[error](err)),
		}
	}
	return  /*line :226:9*/_Ctype_struct_cgx_device_get_result /*line :226:39*/{
		device: ( /*line :227:12*/_Ctype_cgx_device /*line :227:24*/)(wrap[*api.Device](dev)),
	}
}

//export cgx_device_get_runtime
func cgx_device_get_runtime(cgxDevice  /*line :232:39*/_Ctype_cgx_device /*line :232:51*/)  /*line :232:53*/_Ctype_cgx_runtime /*line :232:66*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return ( /*line :234:10*/_Ctype_cgx_runtime /*line :234:23*/)(wrap[*api.Runtime](dev.Runtime()))
}

/* cgx_package_ir */

//export cgx_package_ir_load
func cgx_package_ir_load(cgxRuntime  /*line :240:37*/_Ctype_cgx_runtime /*line :240:50*/, pathPtr * /*line :240:61*/_Ctype_cchar_t /*line :240:70*/)  /*line :240:72*/_Ctype_struct_cgx_package_ir_load_result /*line :240:107*/ {
	rtm := unwrap[*api.Runtime](cgxRuntime)
	pkg, err := rtm.Builder().Build(( /*line :242:34*/_Cfunc_GoString /*line :242:43*/)(pathPtr))
	return  /*line :243:9*/_Ctype_struct_cgx_package_ir_load_result /*line :243:44*/{
		error:    ( /*line :244:14*/_Ctype_cgx_error /*line :244:25*/)(wrap[error](err)),
		_package: ( /*line :245:14*/_Ctype_cgx_package_ir /*line :245:30*/)(wrap[builder.Package](pkg)),
	}
}

/* cgx_package */

type packageHandle struct {
	dev *api.Device
	pkg builder.Package
}

func newPackageHandle(dev *api.Device, pkg builder.Package) *packageHandle {
	if pkg == nil {
		return nil
	}
	return &packageHandle{
		pkg: pkg,
		dev: dev,
	}
}

// NewPackageHandle returns a new C handle to compile a package for a runtime and a device.
// The returned value always has type C.cgx_package.
func NewPackageHandle(dev *api.Device, pkg builder.Package)  /*line :268:61*/_Ctype_cgx_handle /*line :268:73*/ {
	return wrap[*packageHandle](newPackageHandle(dev, pkg))
}

//export cgx_package_ir_build_for
func cgx_package_ir_build_for(cgxPackageIR  /*line :273:44*/_Ctype_cgx_package_ir /*line :273:60*/, cgxDevice  /*line :273:72*/_Ctype_cgx_device /*line :273:84*/)  /*line :273:86*/_Ctype_cgx_package /*line :273:99*/ {
	dev := unwrap[*api.Device](cgxDevice)
	pkg := unwrap[builder.Package](cgxPackageIR)
	return  /*line :276:9*/_Ctype_cgx_package /*line :276:22*/(NewPackageHandle(dev, pkg))
}

//export cgx_package_ir_name
func cgx_package_ir_name(cgxPackageIR  /*line :280:39*/_Ctype_cgx_package_ir /*line :280:55*/) * /*line :280:58*/_Ctype_cchar_t /*line :280:67*/ {
	pkg := unwrap[builder.Package](cgxPackageIR)
	return ( /*line :282:9*/_Cfunc_CString /*line :282:17*/)(pkg.IR().Name.Name)
}

//export cgx_package_ir_fullname
func cgx_package_ir_fullname(cgxPackageIR  /*line :286:43*/_Ctype_cgx_package_ir /*line :286:59*/) * /*line :286:62*/_Ctype_cchar_t /*line :286:71*/ {
	pkg := unwrap[builder.Package](cgxPackageIR)
	return ( /*line :288:9*/_Cfunc_CString /*line :288:17*/)(pkg.IR().FullName())
}

//export cgx_package_list_functions
func cgx_package_list_functions(cgxPackage  /*line :292:44*/_Ctype_cgx_package /*line :292:57*/)  /*line :292:59*/_Ctype_struct_cgx_list_functions_result /*line :292:93*/ {
	cpkg := unwrap[*packageHandle](cgxPackage)
	var funcs []*functionHandle
	for fn := range cpkg.pkg.IR().ExportedFuncs() {
		funcs = append(funcs, newFunctionHandle(cpkg.dev, fn))
	}
	return  /*line :298:9*/_Ctype_struct_cgx_list_functions_result /*line :298:43*/{
		funcs:         (* /*line :299:20*/_Ctype_cgx_function /*line :299:34*/)(handle.PinSliceData(handle.WrapSlice(funcs))),
		num_functions:  /*line :300:18*/_Ctype_int /*line :300:23*/(len(funcs)),
	}
}

//export cgx_package_get_ir
func cgx_package_get_ir(cgxPackage  /*line :305:36*/_Ctype_cgx_package /*line :305:49*/)  /*line :305:51*/_Ctype_cgx_package_ir /*line :305:67*/ {
	cpkg := unwrap[*packageHandle](cgxPackage)
	return ( /*line :307:10*/_Ctype_cgx_package_ir /*line :307:26*/)(wrap[builder.Package](cpkg.pkg))
}

//export cgx_free_list_functions_result
func cgx_free_list_functions_result(res * /*line :311:42*/_Ctype_struct_cgx_list_functions_result /*line :311:76*/) {
	handle.UnpinSliceData(unsafe.Pointer(res.funcs))
	res.funcs = nil
	res.num_functions = 0
}

//export cgx_interface_find
func cgx_interface_find(cgxPackage  /*line :318:36*/_Ctype_cgx_package /*line :318:49*/, cname * /*line :318:58*/_Ctype_cchar_t /*line :318:67*/) (res  /*line :318:74*/_Ctype_struct_cgx_interface_find_result /*line :318:108*/) {
	cpkg := unwrap[*packageHandle](cgxPackage)
	name := ( /*line :320:10*/_Cfunc_GoString /*line :320:19*/)(cname)
	irPkg := cpkg.pkg.IR()
	for _, typ := range irPkg.ExportedTypes() {
		if typ.Name() == name {
			res.iface = ( /*line :324:17*/_Ctype_cgx_interface /*line :324:32*/)(wrap[*interfaceHandle](newInterfaceHandle(cpkg.dev, typ)))
			return
		}
	}
	res.error = Errorf("type %q not found in package %q", name, irPkg.Name.String())
	return
}

/* cgx_function */

type functionHandle struct {
	dev   *api.Device
	fn    ir.Func
	graph tracer.CompiledFunc
}

func newFunctionHandle(dev *api.Device, fn ir.Func) *functionHandle {
	if dev == nil {
		panic("nil device")
	}
	return &functionHandle{dev: dev, fn: fn}
}

func (f *functionHandle) compile(receiver values.Value, args []values.Value, options []options.PackageOption) (err error) {
	fDecl, ok := f.fn.(*ir.FuncDecl)
	if !ok {
		return errors.Errorf("cannot run %s.%s: builtin functions not supported", f.fn.File().Package.Name.Name, f.fn.Name())
	}
	f.graph, err = tracer.Trace(f.dev, fDecl, receiver, args, options)
	return
}

//export cgx_function_find
func cgx_function_find(cgxPackage  /*line :357:35*/_Ctype_cgx_package /*line :357:48*/, funcNamePtr * /*line :357:63*/_Ctype_cchar_t /*line :357:72*/) (res  /*line :357:79*/_Ctype_struct_cgx_function_find_result /*line :357:112*/) {
	cpkg := unwrap[*packageHandle](cgxPackage)
	name := ( /*line :359:10*/_Cfunc_GoString /*line :359:19*/)(funcNamePtr)
	if !ir.IsExported(name) {
		res.error = Errorf("function %q not exported", name)
		return
	}
	irPkg := cpkg.pkg.IR()
	fun := irPkg.FindFunc(name)
	if fun == nil {
		res.error = Errorf("function %q not found in package %q", name, irPkg.Name)
		return
	}
	res.function = ( /*line :370:18*/_Ctype_cgx_function /*line :370:32*/)(wrap[*functionHandle](newFunctionHandle(cpkg.dev, fun)))
	return
}

//export cgx_function_run
func cgx_function_run(cgxFunction  /*line :375:35*/_Ctype_cgx_function /*line :375:49*/, cgxReceiver  /*line :375:63*/_Ctype_cgx_value /*line :375:74*/, argCount  /*line :375:85*/_Ctype_int /*line :375:90*/, args * /*line :375:98*/_Ctype_cgx_value /*line :375:109*/)  /*line :375:111*/_Ctype_struct_cgx_function_run_result /*line :375:143*/ {
	function := unwrap[*functionHandle](cgxFunction)
	recvValue := unwrap[values.Value](cgxReceiver)
	cgxValues := unsafe.Slice(args, argCount)
	argValues := make([]values.Value, int(argCount))
	for i, cgxValue := range cgxValues {
		argValues[i] = unwrap[values.Value](cgxValue)
	}
	// If we haven't built a compiled graph yet, do so and cache it in the function handle.
	if function.graph == nil {
		if err := function.compile(recvValue, argValues, nil); err != nil {
			return  /*line :386:11*/_Ctype_struct_cgx_function_run_result /*line :386:43*/{error: ( /*line :386:52*/_Ctype_cgx_error /*line :386:63*/)(wrap[error](err))}
		}
	}
	results, err := function.graph.Run(recvValue, argValues, nil)
	if err != nil {
		return  /*line :391:10*/_Ctype_struct_cgx_function_run_result /*line :391:42*/{error: ( /*line :391:51*/_Ctype_cgx_error /*line :391:62*/)(wrap[error](err))}
	}
	return  /*line :393:9*/_Ctype_struct_cgx_function_run_result /*line :393:41*/{
		values:     (* /*line :394:17*/_Ctype_cgx_value /*line :394:28*/)(handle.PinSliceData(handle.WrapSlice(results))),
		value_size:  /*line :395:15*/_Ctype_uint32_t /*line :395:25*/(len(results)),
	}
}

//export cgx_function_name
func cgx_function_name(cgxFunction  /*line :400:36*/_Ctype_cgx_function /*line :400:50*/) * /*line :400:53*/_Ctype_cchar_t /*line :400:62*/ {
	function := unwrap[*functionHandle](cgxFunction)
	return ( /*line :402:9*/_Cfunc_CString /*line :402:17*/)(function.fn.Name())
}

//export cgx_function_doc
func cgx_function_doc(cgxFunction  /*line :406:35*/_Ctype_cgx_function /*line :406:49*/) * /*line :406:52*/_Ctype_cchar_t /*line :406:61*/ {
	function := unwrap[*functionHandle](cgxFunction)
	return ( /*line :408:9*/_Cfunc_CString /*line :408:17*/)(function.fn.Doc().Text())
}

func copySignatureElements(fields *ir.FieldList) * /*line :411:51*/_Ctype_struct_cgx_function_signature_element /*line :411:90*/ {
	elements := make([] /*line :412:21*/_Ctype_struct_cgx_function_signature_element /*line :412:60*/, fields.Len())
	for n, field := range fields.Fields() {
		elements[n].name = ( /*line :414:22*/_Cfunc_CString /*line :414:30*/)(field.Name.String())
		elements[n].kind = toCGXValueKind(field.Type().Kind())
	}
	return (* /*line :417:11*/_Ctype_struct_cgx_function_signature_element /*line :417:50*/)(handle.PinSliceData(elements))
}

//export cgx_function_signature
func cgx_function_signature(cgxFunction  /*line :421:41*/_Ctype_cgx_function /*line :421:55*/)  /*line :421:57*/_Ctype_struct_cgx_function_signature_result /*line :421:95*/ {
	function := unwrap[*functionHandle](cgxFunction)
	result :=  /*line :423:12*/_Ctype_struct_cgx_function_signature_result /*line :423:50*/{
		parameter:      copySignatureElements(function.fn.FuncType().Params),
		parameter_size:  /*line :425:19*/_Ctype_uint32_t /*line :425:29*/(function.fn.FuncType().Params.Len()),
		result:         copySignatureElements(function.fn.FuncType().Results),
		result_size:     /*line :427:19*/_Ctype_uint32_t /*line :427:29*/(function.fn.FuncType().Results.Len()),
	}
	return result
}

//export cgx_free_function_signature_result
func cgx_free_function_signature_result(cgxSignature * /*line :433:55*/_Ctype_struct_cgx_function_signature_result /*line :433:93*/) {
	freeSignature := func(list * /*line :434:30*/_Ctype_struct_cgx_function_signature_element /*line :434:69*/, size  /*line :434:76*/_Ctype_uint32_t /*line :434:86*/) {
		for _, item := range unsafe.Slice(list, size) {
			func() { _cgo0 := /*line :436:11*/unsafe.Pointer(item.name); _cgoCheckPointer(_cgo0, nil); /*line :436:37*/_Cfunc_free(_cgo0); }()
		}
		handle.UnpinSliceData(unsafe.Pointer(list))
	}
	freeSignature(cgxSignature.parameter, cgxSignature.parameter_size)
	cgxSignature.parameter = nil
	cgxSignature.parameter_size = 0
	freeSignature(cgxSignature.result, cgxSignature.result_size)
	cgxSignature.result = nil
	cgxSignature.result_size = 0
}

//export cgx_function_num_params
func cgx_function_num_params(cgxFunction  /*line :449:42*/_Ctype_cgx_function /*line :449:56*/) int {
	function := unwrap[*functionHandle](cgxFunction)
	return function.fn.FuncType().Params.Len()
}

//export cgx_function_param_dtype
func cgx_function_param_dtype(cgxFunction  /*line :455:43*/_Ctype_cgx_function /*line :455:57*/, arg int)  /*line :455:68*/_Ctype_enum_cgx_value_kind /*line :455:89*/ {
	function := unwrap[*functionHandle](cgxFunction)
	params := function.fn.FuncType().Params.Fields()
	if arg < 0 || arg >= len(params) {
		return ( /*line :459:10*/_Ciconst_CGX_INVALID /*line :459:22*/)
	}
	_, dtype := ir.Shape(params[arg].Type())
	return toCGXValueKind(dtype.Kind())
}

//export cgx_free_function_run_result
func cgx_free_function_run_result(cgxFunctionResult * /*line :466:54*/_Ctype_struct_cgx_function_run_result /*line :466:86*/) {
	handle.UnpinSliceData(unsafe.Pointer(cgxFunctionResult.values))
	cgxFunctionResult.values = nil
}

/* cgx_value */

func toValueResult[T dtype.GoDataType](devAtom *types.DeviceAtom[T], err error)  /*line :473:81*/_Ctype_struct_cgx_value_new_result /*line :473:110*/ {
	if err != nil {
		return  /*line :475:10*/_Ctype_struct_cgx_value_new_result /*line :475:39*/{error: ( /*line :475:48*/_Ctype_cgx_error /*line :475:59*/)(wrap[error](err))}
	}
	return  /*line :477:9*/_Ctype_struct_cgx_value_new_result /*line :477:38*/{
		value: ( /*line :478:11*/_Ctype_cgx_value /*line :478:22*/)(wrap[values.Value](devAtom.GXValue())),
	}
}

//export cgx_value_new_bool
func cgx_value_new_bool(cgxDevice  /*line :483:35*/_Ctype_cgx_device /*line :483:47*/, value  /*line :483:55*/_Ctype_bool /*line :483:61*/)  /*line :483:63*/_Ctype_struct_cgx_value_new_result /*line :483:92*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Bool(bool(value)).SendTo(dev))
}

//export cgx_value_new_float32
func cgx_value_new_float32(cgxDevice  /*line :489:38*/_Ctype_cgx_device /*line :489:50*/, value  /*line :489:58*/_Ctype_float /*line :489:65*/)  /*line :489:67*/_Ctype_struct_cgx_value_new_result /*line :489:96*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Float32(float32(value)).SendTo(dev))
}

//export cgx_value_new_float64
func cgx_value_new_float64(cgxDevice  /*line :495:38*/_Ctype_cgx_device /*line :495:50*/, value  /*line :495:58*/_Ctype_double /*line :495:66*/)  /*line :495:68*/_Ctype_struct_cgx_value_new_result /*line :495:97*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Float64(float64(value)).SendTo(dev))
}

//export cgx_value_new_int32
func cgx_value_new_int32(cgxDevice  /*line :501:36*/_Ctype_cgx_device /*line :501:48*/, value  /*line :501:56*/_Ctype_int32_t /*line :501:65*/)  /*line :501:67*/_Ctype_struct_cgx_value_new_result /*line :501:96*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Int32(int32(value)).SendTo(dev))
}

//export cgx_value_new_int64
func cgx_value_new_int64(cgxDevice  /*line :507:36*/_Ctype_cgx_device /*line :507:48*/, value  /*line :507:56*/_Ctype_int64_t /*line :507:65*/)  /*line :507:67*/_Ctype_struct_cgx_value_new_result /*line :507:96*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Int64(int64(value)).SendTo(dev))
}

//export cgx_value_new_uint32
func cgx_value_new_uint32(cgxDevice  /*line :513:37*/_Ctype_cgx_device /*line :513:49*/, value  /*line :513:57*/_Ctype_uint32_t /*line :513:67*/)  /*line :513:69*/_Ctype_struct_cgx_value_new_result /*line :513:98*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Uint32(uint32(value)).SendTo(dev))
}

//export cgx_value_new_uint64
func cgx_value_new_uint64(cgxDevice  /*line :519:37*/_Ctype_cgx_device /*line :519:49*/, value  /*line :519:57*/_Ctype_uint64_t /*line :519:67*/)  /*line :519:69*/_Ctype_struct_cgx_value_new_result /*line :519:98*/ {
	dev := unwrap[*api.Device](cgxDevice)
	return toValueResult(types.Uint64(uint64(value)).SendTo(dev))
}

//export cgx_value_send
func cgx_value_send(cgxDevice  /*line :525:31*/_Ctype_cgx_device /*line :525:43*/, cgxShape  /*line :525:54*/_Ctype_cgx_shape /*line :525:65*/, data * /*line :525:73*/_Ctype_cvoid_t /*line :525:82*/, dataSize  /*line :525:93*/_Ctype_uint64_t /*line :525:103*/)  /*line :525:105*/_Ctype_struct_cgx_value_new_result /*line :525:134*/ {
	dev := unwrap[*api.Device](cgxDevice)
	shape := unwrap[*shape.Shape](cgxShape)
	byteData := (*byte)(unsafe.Pointer(data))

	h, err := dev.PlatformDevice().Send(unsafe.Slice(byteData, dataSize), shape)
	if err != nil {
		return  /*line :532:10*/_Ctype_struct_cgx_value_new_result /*line :532:39*/{error: ( /*line :532:48*/_Ctype_cgx_error /*line :532:59*/)(wrap[error](err))}
	}
	dataType := ir.TypeFromKind(ir.Kind(shape.DType))
	valueType := ir.NewArrayType(nil, dataType, ir.NewRank(shape.AxisLengths))
	value, err := values.NewDeviceArray(valueType, h)
	if err != nil {
		return  /*line :538:10*/_Ctype_struct_cgx_value_new_result /*line :538:39*/{error: ( /*line :538:48*/_Ctype_cgx_error /*line :538:59*/)(wrap[error](err))}
	}
	return  /*line :540:9*/_Ctype_struct_cgx_value_new_result /*line :540:38*/{
		value: ( /*line :541:11*/_Ctype_cgx_value /*line :541:22*/)(wrap[values.Value](value)),
	}
}

func toCGXValueKind(kind ir.Kind)  /*line :545:35*/_Ctype_enum_cgx_value_kind /*line :545:56*/ {
	switch kind {
	case ir.BoolKind:
		return ( /*line :548:10*/_Ciconst_CGX_BOOL /*line :548:19*/)
	case ir.Bfloat16Kind:
		return ( /*line :550:10*/_Ciconst_CGX_BFLOAT16 /*line :550:23*/)
	case ir.Float32Kind:
		return ( /*line :552:10*/_Ciconst_CGX_FLOAT32 /*line :552:22*/)
	case ir.Float64Kind:
		return ( /*line :554:10*/_Ciconst_CGX_FLOAT64 /*line :554:22*/)
	case ir.Int32Kind:
		return ( /*line :556:10*/_Ciconst_CGX_INT32 /*line :556:20*/)
	case ir.Int64Kind:
		return ( /*line :558:10*/_Ciconst_CGX_INT64 /*line :558:20*/)
	case ir.Uint32Kind:
		return ( /*line :560:10*/_Ciconst_CGX_UINT32 /*line :560:21*/)
	case ir.Uint64Kind:
		return ( /*line :562:10*/_Ciconst_CGX_UINT64 /*line :562:21*/)
	case ir.ArrayKind:
		return ( /*line :564:10*/_Ciconst_CGX_ARRAY /*line :564:20*/)
	case ir.SliceKind:
		return ( /*line :566:10*/_Ciconst_CGX_SLICE /*line :566:20*/)
	case ir.StructKind:
		return ( /*line :568:10*/_Ciconst_CGX_STRUCT /*line :568:21*/)
	default:
		return ( /*line :570:10*/_Ciconst_CGX_INVALID /*line :570:22*/)
	}
}

//export cgx_value_kind_of
func cgx_value_kind_of(cgxValue  /*line :575:33*/_Ctype_cgx_value /*line :575:44*/)  /*line :575:46*/_Ctype_enum_cgx_value_kind /*line :575:67*/ {
	value := unwrap[values.Value](cgxValue)
	return toCGXValueKind(value.Type().Kind())
}

//export cgx_value_shape
func cgx_value_shape(cgxValue  /*line :581:31*/_Ctype_cgx_value /*line :581:42*/)  /*line :581:44*/_Ctype_cgx_shape /*line :581:55*/ {
	value := unwrap[values.Value](cgxValue)
	if array, ok := value.(values.Array); ok {
		return ( /*line :584:11*/_Ctype_cgx_shape /*line :584:22*/)(wrap[*shape.Shape](array.Shape()))
	}
	return 0
}

func atomFromDeviceArray[T dtype.GoDataType](cgxValue  /*line :589:55*/_Ctype_cgx_value /*line :589:66*/) T {
	value := unwrap[values.Value](cgxValue)
	atomDevice := types.NewDeviceAtom[T](value.(*values.DeviceArray))
	atomHost, err := atomDevice.Fetch()
	if err != nil {
		panic(err)
	}
	return atomHost.Value()
}

//export cgx_value_get_bool
func cgx_value_get_bool(cgxValue  /*line :600:34*/_Ctype_cgx_value /*line :600:45*/)  /*line :600:47*/_Ctype_bool /*line :600:53*/ {
	return  /*line :601:9*/_Ctype_bool /*line :601:15*/(atomFromDeviceArray[bool](cgxValue))
}

//export cgx_value_get_float32
func cgx_value_get_float32(cgxValue  /*line :605:37*/_Ctype_cgx_value /*line :605:48*/)  /*line :605:50*/_Ctype_float /*line :605:57*/ {
	return  /*line :606:9*/_Ctype_float /*line :606:16*/(atomFromDeviceArray[float32](cgxValue))
}

//export cgx_value_get_float64
func cgx_value_get_float64(cgxValue  /*line :610:37*/_Ctype_cgx_value /*line :610:48*/)  /*line :610:50*/_Ctype_double /*line :610:58*/ {
	return  /*line :611:9*/_Ctype_double /*line :611:17*/(atomFromDeviceArray[float64](cgxValue))
}

//export cgx_value_get_int32
func cgx_value_get_int32(cgxValue  /*line :615:35*/_Ctype_cgx_value /*line :615:46*/)  /*line :615:48*/_Ctype_int32_t /*line :615:57*/ {
	return  /*line :616:9*/_Ctype_int32_t /*line :616:18*/(atomFromDeviceArray[int32](cgxValue))
}

//export cgx_value_get_int64
func cgx_value_get_int64(cgxValue  /*line :620:35*/_Ctype_cgx_value /*line :620:46*/)  /*line :620:48*/_Ctype_int64_t /*line :620:57*/ {
	return  /*line :621:9*/_Ctype_int64_t /*line :621:18*/(atomFromDeviceArray[int64](cgxValue))
}

//export cgx_value_get_uint32
func cgx_value_get_uint32(cgxValue  /*line :625:36*/_Ctype_cgx_value /*line :625:47*/)  /*line :625:49*/_Ctype_uint32_t /*line :625:59*/ {
	return  /*line :626:9*/_Ctype_uint32_t /*line :626:19*/(atomFromDeviceArray[uint32](cgxValue))
}

//export cgx_value_get_uint64
func cgx_value_get_uint64(cgxValue  /*line :630:36*/_Ctype_cgx_value /*line :630:47*/)  /*line :630:49*/_Ctype_uint64_t /*line :630:59*/ {
	return  /*line :631:9*/_Ctype_uint64_t /*line :631:19*/(atomFromDeviceArray[uint64](cgxValue))
}

//export cgx_value_host_buffer
func cgx_value_host_buffer(cgxValue  /*line :635:37*/_Ctype_cgx_value /*line :635:48*/)  /*line :635:50*/_Ctype_struct_cgx_value_host_buffer_result /*line :635:87*/ {
	value := unwrap[values.Value](cgxValue)
	deviceArray := value.(*values.DeviceArray)
	hostArray, err := deviceArray.ToHostArray(kernels.Allocator())
	if err != nil {
		return  /*line :640:10*/_Ctype_struct_cgx_value_host_buffer_result /*line :640:47*/{}
	}
	return  /*line :642:9*/_Ctype_struct_cgx_value_host_buffer_result /*line :642:46*/{
		buffer: ( /*line :643:12*/_Ctype_cgx_host_buffer /*line :643:29*/)(wrap[platform.HostBuffer](hostArray.Buffer())),
	}
}

//export cgx_value_get_struct
func cgx_value_get_struct(cgxValue  /*line :648:36*/_Ctype_cgx_value /*line :648:47*/)  /*line :648:49*/_Ctype_struct_cgx_value_get_struct_result /*line :648:85*/ {
	value := unwrap[values.Value](cgxValue)
	kind := value.Type().Kind()
	if value.Type().Kind() != ir.StructKind {
		return  /*line :652:10*/_Ctype_struct_cgx_value_get_struct_result /*line :652:46*/{
			error: Errorf("value has kind %v, expect kind %v", kind, ir.StructKind),
		}
	}
	strct := values.Underlying(value).(*values.Struct)
	return  /*line :657:9*/_Ctype_struct_cgx_value_get_struct_result /*line :657:45*/{
		strct: ( /*line :658:11*/_Ctype_cgx_struct /*line :658:23*/)(wrap[*structHandle](&structHandle{value: strct})),
	}
}

//export cgx_value_get_interface_type
func cgx_value_get_interface_type(cgxDevice  /*line :663:45*/_Ctype_cgx_device /*line :663:57*/, cgxValue  /*line :663:68*/_Ctype_cgx_value /*line :663:79*/)  /*line :663:81*/_Ctype_cgx_interface /*line :663:96*/ {
	value := unwrap[values.Value](cgxValue)
	namedType, ok := value.Type().(*ir.NamedType)
	if !ok {
		return 0
	}
	device := unwrap[*api.Device](cgxDevice)
	return ( /*line :670:10*/_Ctype_cgx_interface /*line :670:25*/)(wrap[*interfaceHandle](newInterfaceHandle(device, namedType)))
}

//export cgx_value_string
func cgx_value_string(cgxValue  /*line :674:32*/_Ctype_cgx_value /*line :674:43*/) * /*line :674:46*/_Ctype_cchar_t /*line :674:55*/ {
	value := unwrap[values.Value](cgxValue)
	return ( /*line :676:9*/_Cfunc_CString /*line :676:17*/)(value.String())
}

/* cgx_shape */

func fromCGXValueKind(valueType  /*line :681:33*/_Ctype_enum_cgx_value_kind /*line :681:54*/) dtype.DataType {
	switch valueType {
	case ( /*line :683:7*/_Ciconst_CGX_BOOL /*line :683:16*/):
		return dtype.Bool
	case ( /*line :685:7*/_Ciconst_CGX_BFLOAT16 /*line :685:20*/):
		return dtype.Bfloat16
	case ( /*line :687:7*/_Ciconst_CGX_FLOAT32 /*line :687:19*/):
		return dtype.Float32
	case ( /*line :689:7*/_Ciconst_CGX_FLOAT64 /*line :689:19*/):
		return dtype.Float64
	case ( /*line :691:7*/_Ciconst_CGX_INT32 /*line :691:17*/):
		return dtype.Int32
	case ( /*line :693:7*/_Ciconst_CGX_INT64 /*line :693:17*/):
		return dtype.Int64
	case ( /*line :695:7*/_Ciconst_CGX_UINT32 /*line :695:18*/):
		return dtype.Uint32
	case ( /*line :697:7*/_Ciconst_CGX_UINT64 /*line :697:18*/):
		return dtype.Uint64
	default:
		return dtype.Invalid
	}
}

//export cgx_shape_new
func cgx_shape_new(dtype  /*line :705:26*/_Ctype_enum_cgx_value_kind /*line :705:47*/, axisLengths * /*line :705:62*/_Ctype_cint64_t /*line :705:72*/, axisLengthsSize  /*line :705:90*/_Ctype_int /*line :705:95*/)  /*line :705:97*/_Ctype_cgx_shape /*line :705:108*/ {
	return ( /*line :706:10*/_Ctype_cgx_shape /*line :706:21*/)(wrap[*shape.Shape](&shape.Shape{
		DType:       fromCGXValueKind(dtype),
		AxisLengths: copyPrimitiveSlice[int](unsafe.Pointer(axisLengths), int(axisLengthsSize)),
	}))
}

//export cgx_shape_axes
func cgx_shape_axes(cgxShape  /*line :713:30*/_Ctype_cgx_shape /*line :713:41*/)  /*line :713:43*/_Ctype_struct_cgx_shape_axes_result /*line :713:73*/ {
	shape := unwrap[*shape.Shape](cgxShape)
	return  /*line :715:9*/_Ctype_struct_cgx_shape_axes_result /*line :715:39*/{
		axis_lengths: (* /*line :716:19*/_Ctype_cint64_t /*line :716:29*/)(handle.PinSliceData[int](shape.AxisLengths)),
		num_axes:      /*line :717:17*/_Ctype_uint32_t /*line :717:27*/(len(shape.AxisLengths)),
	}
}

//export cgx_free_shape_axes_result
func cgx_free_shape_axes_result(cgxShapeResult * /*line :722:49*/_Ctype_struct_cgx_shape_axes_result /*line :722:79*/) {
	handle.UnpinSliceData(unsafe.Pointer(cgxShapeResult.axis_lengths))
	cgxShapeResult.axis_lengths = nil
	cgxShapeResult.num_axes = 0
}

//export cgx_shape_size
func cgx_shape_size(cgxShape  /*line :729:30*/_Ctype_cgx_shape /*line :729:41*/)  /*line :729:43*/_Ctype_int /*line :729:48*/ {
	shape := unwrap[*shape.Shape](cgxShape)
	return  /*line :731:9*/_Ctype_int /*line :731:14*/(shape.Size())
}

//export cgx_shape_element_kind
func cgx_shape_element_kind(cgxShape  /*line :735:38*/_Ctype_cgx_shape /*line :735:49*/)  /*line :735:51*/_Ctype_enum_cgx_value_kind /*line :735:72*/ {
	shape := unwrap[*shape.Shape](cgxShape)
	if shape.DType < dtype.MaxDataType {
		return toCGXValueKind(ir.Kind(shape.DType))
	}
	return ( /*line :740:9*/_Ciconst_CGX_INVALID /*line :740:21*/)
}

/* cgx_host_buffer */

//export cgx_host_buffer_acquire_data
func cgx_host_buffer_acquire_data(cgxHostBuffer  /*line :746:49*/_Ctype_cgx_host_buffer /*line :746:66*/) * /*line :746:69*/_Ctype_char /*line :746:75*/ {
	hostBuffer := unwrap[platform.HostBuffer](cgxHostBuffer)
	data := hostBuffer.Acquire()
	return (* /*line :749:11*/_Ctype_char /*line :749:17*/)(handle.PinSliceData[byte](data))
}

//export cgx_host_buffer_release_data
func cgx_host_buffer_release_data(cgxHostBuffer  /*line :753:49*/_Ctype_cgx_host_buffer /*line :753:66*/, data * /*line :753:74*/_Ctype_char /*line :753:80*/) {
	hostBuffer := unwrap[platform.HostBuffer](cgxHostBuffer)
	handle.UnpinSliceData(unsafe.Pointer(data))
	hostBuffer.Release()
}

/* cgx_struct */

type structHandle struct {
	value *values.Struct
}

//export cgx_struct_field_get
func cgx_struct_field_get(cgxStruct  /*line :766:37*/_Ctype_cgx_struct /*line :766:49*/, fieldNamePtr * /*line :766:65*/_Ctype_cchar_t /*line :766:74*/) (res  /*line :766:81*/_Ctype_struct_cgx_value_new_result /*line :766:110*/) {
	h := unwrap[*structHandle](cgxStruct)
	fieldValue := h.value.FieldValue(( /*line :768:35*/_Cfunc_GoString /*line :768:44*/)(fieldNamePtr))
	return  /*line :769:9*/_Ctype_struct_cgx_value_new_result /*line :769:38*/{
		value: ( /*line :770:11*/_Ctype_cgx_value /*line :770:22*/)(wrap[values.Value](fieldValue)),
	}
}

//export cgx_struct_field_set
func cgx_struct_field_set(cgxStruct  /*line :775:37*/_Ctype_cgx_struct /*line :775:49*/, fieldNamePtr * /*line :775:65*/_Ctype_cchar_t /*line :775:74*/, cgxValue  /*line :775:85*/_Ctype_cgx_value /*line :775:96*/)  /*line :775:98*/_Ctype_cgx_error /*line :775:109*/ {
	h := unwrap[*structHandle](cgxStruct)
	value := unwrap[values.Value](cgxValue)
	h.value.SetField(( /*line :778:19*/_Cfunc_GoString /*line :778:28*/)(fieldNamePtr), value)
	return ( /*line :779:10*/_Ctype_cgx_error /*line :779:21*/)(wrap[error](nil))
}

//export cgx_struct_field_list
func cgx_struct_field_list(cgxStruct  /*line :783:38*/_Ctype_cgx_struct /*line :783:50*/) (res  /*line :783:57*/_Ctype_struct_cgx_struct_field_list_result /*line :783:94*/) {
	h := unwrap[*structHandle](cgxStruct)
	fields := h.value.StructType().Fields.Fields()
	result := make([] /*line :786:19*/_Ctype_struct_cgx_struct_field_element /*line :786:52*/, len(fields))
	for n, field := range fields {
		result[n] =  /*line :788:15*/_Ctype_struct_cgx_struct_field_element /*line :788:48*/{
			name: ( /*line :789:10*/_Cfunc_CString /*line :789:18*/)(field.Name.String()),
			kind: toCGXValueKind(field.Type().Kind()),
		}
	}
	return  /*line :793:9*/_Ctype_struct_cgx_struct_field_list_result /*line :793:46*/{
		field:      (* /*line :794:17*/_Ctype_struct_cgx_struct_field_element /*line :794:50*/)(handle.PinSliceData(result)),
		field_size:  /*line :795:15*/_Ctype_uint32_t /*line :795:25*/(len(result)),
	}
}

//export cgx_free_struct_field_list_result
func cgx_free_struct_field_list_result(cgxFieldList * /*line :800:54*/_Ctype_struct_cgx_struct_field_list_result /*line :800:91*/) {
	for _, item := range unsafe.Slice(cgxFieldList.field, cgxFieldList.field_size) {
		func() { _cgo0 := /*line :802:10*/unsafe.Pointer(item.name); _cgoCheckPointer(_cgo0, nil); /*line :802:36*/_Cfunc_free(_cgo0); }()
	}
	handle.UnpinSliceData(unsafe.Pointer(cgxFieldList.field))
	cgxFieldList.field = nil
	cgxFieldList.field_size = 0
}

/* cgx_interface */

type interfaceHandle struct {
	device *api.Device
	typ    *ir.NamedType
}

func newInterfaceHandle(dev *api.Device, typ *ir.NamedType) *interfaceHandle {
	if dev == nil {
		panic("nil device")
	}
	return &interfaceHandle{device: dev, typ: typ}
}

//export cgx_interface_method_find
func cgx_interface_method_find(cgxIFace  /*line :824:41*/_Ctype_cgx_interface /*line :824:56*/, methodNamePtr * /*line :824:73*/_Ctype_cchar_t /*line :824:82*/) (res  /*line :824:89*/_Ctype_struct_cgx_function_find_result /*line :824:122*/) {
	iface := unwrap[*interfaceHandle](cgxIFace)
	methodName := ( /*line :826:16*/_Cfunc_GoString /*line :826:25*/)(methodNamePtr)
	method := iface.typ.MethodByName(methodName)
	if method == nil {
		packageName := iface.typ.File.Package.Name.Name
		typeName := iface.typ.Name()
		res.error = Errorf("type %s.%s has no method %s", packageName, typeName, methodName)
		return
	}
	res.function = ( /*line :834:18*/_Ctype_cgx_function /*line :834:32*/)(wrap[*functionHandle](newFunctionHandle(iface.device, method)))
	return
}

//export cgx_interface_name
func cgx_interface_name(cgxIFace  /*line :839:34*/_Ctype_cgx_interface /*line :839:49*/) * /*line :839:52*/_Ctype_cchar_t /*line :839:61*/ {
	iface := unwrap[*interfaceHandle](cgxIFace)
	return ( /*line :841:9*/_Cfunc_CString /*line :841:17*/)(iface.typ.Name())
}

//export cgx_interface_package_name
func cgx_interface_package_name(cgxIFace  /*line :845:42*/_Ctype_cgx_interface /*line :845:57*/) * /*line :845:60*/_Ctype_cchar_t /*line :845:69*/ {
	iface := unwrap[*interfaceHandle](cgxIFace)
	return ( /*line :847:9*/_Cfunc_CString /*line :847:17*/)(iface.typ.File.Package.FullName())
}

//export cgx_interface_list_methods
func cgx_interface_list_methods(cgxIFace  /*line :851:42*/_Ctype_cgx_interface /*line :851:57*/)  /*line :851:59*/_Ctype_struct_cgx_list_functions_result /*line :851:93*/ {
	iface := unwrap[*interfaceHandle](cgxIFace)
	var funcs []*functionHandle
	for _, fn := range iface.typ.Methods {
		if !ir.IsExported(fn.Name()) {
			continue
		}
		funcs = append(funcs, newFunctionHandle(iface.device, fn))
	}
	return  /*line :860:9*/_Ctype_struct_cgx_list_functions_result /*line :860:43*/{
		funcs:         (* /*line :861:20*/_Ctype_cgx_function /*line :861:34*/)(handle.PinSliceData(handle.WrapSlice(funcs))),
		num_functions:  /*line :862:18*/_Ctype_int /*line :862:23*/(len(funcs)),
	}
}

// Required for cgo to build C libraries.
func main() {}
