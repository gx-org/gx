// Package bindings provides abstractions shared by all bindings generators.
package bindings

import (
	"fmt"
	"io"

	"github.com/gx-org/gx/build/ir"
)

type (
	// New returns a new binder.
	New func(*ir.Package) (Binder, error)

	// File generated by the binder.
	File interface {
		// Extension of the generated file
		// (for example: .go, .cc, or .h).
		Extension() string

		// WriteBindings the content of the file.
		WriteBindings(io.Writer) error
	}

	// Binder writes the bindings for a specific language.
	Binder interface {
		Files() []File
	}
)

// CanBeOnDeviceFunc returns true if a function can be implemented on a device.
func CanBeOnDeviceFunc(gxFunc ir.Func) bool {
	_, isGX := gxFunc.(*ir.FuncDecl)
	if !isGX {
		return false
	}
	tp := gxFunc.FuncType()
	for _, arg := range tp.Params.Fields() {
		if err := CanBeOnDevice(arg.Type()); err != nil {
			return false
		}
	}
	return true
}

func canBeOnDeviceStruct(tp *ir.StructType) error {
	for _, group := range tp.Fields.List {
		if err := CanBeOnDevice(group.Type); err != nil {
			var fieldNames []string
			for _, field := range group.Fields {
				fieldNames = append(fieldNames, field.Name.Name)
			}
			return fmt.Errorf("cannot store on device fields %v: %v", fieldNames, err)
		}
	}
	return nil
}

// CanBeOnDevice returns true if a type can be on device.
func CanBeOnDevice(tp ir.Type) error {
	if _, ok := tp.(ir.ArrayType); ok {
		return nil
	}
	switch typT := tp.(type) {
	case *ir.NamedType:
		return CanBeOnDevice(typT.Underlying)
	case *ir.StructType:
		return canBeOnDeviceStruct(typT)
	case *ir.SliceType:
		return CanBeOnDevice(typT.DType)
	default:
		return fmt.Errorf("type %T not supported", typT)
	}
}

// BuildFuncs collects all the functions of a package for which bindings are generated.
func BuildFuncs[T any](pkg *ir.Package, factory func(ir.Func, int) (*T, error)) ([]*T, error) {
	funcs := []*T{}
	for i, gxFunc := range pkg.Funcs {
		if !ir.IsExported(gxFunc.Name()) {
			continue
		}
		if gxFunc.Type() == nil || gxFunc.FuncType() == nil {
			// Skipping generic functions (not supported).
			continue
		}
		if gxFunc.FuncType().Receiver != nil {
			continue
		}
		if !CanBeOnDeviceFunc(gxFunc) {
			continue
		}
		fn, err := factory(gxFunc, i)
		if err != nil {
			return nil, err
		}
		funcs = append(funcs, fn)
	}
	return funcs, nil
}

// IsDefaultInt returns true if the kind can be converted to the system default integer type.
func IsDefaultInt(kind ir.Kind) bool {
	return kind == ir.IntLenKind || kind == ir.IntIdxKind
}
